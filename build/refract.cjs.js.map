{"version":3,"file":"refract.cjs.js","sources":["../src/utils/general.ts","../src/rendering/constants.ts","../src/lib.ts","../src/rendering/props.ts","../src/signals/signal.ts","../src/signals/batch.ts","../src/rendering/createElements.ts","../src/rendering/render.ts","../src/rendering/functionalComponents.ts","../src/lazy/Lazyloading.tsx"],"sourcesContent":["export function isPlainObject(variable: any) {\r\n    return (\r\n        typeof variable === \"object\" && // Must be an object\r\n        variable !== null && // Cannot be null\r\n        !Array.isArray(variable) && // Cannot be an array\r\n        Object.prototype.toString.call(variable) === \"[object Object]\" // Must be a plain object\r\n    );\r\n}\r\nexport function isPrimitive(val: any) {\r\n    return (\r\n        [\"boolean\", \"string\", \"number\", \"undefined\"].includes(typeof val) ||\r\n        val === null ||\r\n        val instanceof Error\r\n    );\r\n}\r\n\r\nexport function swap(arr: any[], i: number, j: number) {\r\n    const temp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = temp;\r\n}\r\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\r\nexport const SVG_TAGS = new Set([\r\n    \"svg\",\r\n    \"a\",\r\n    \"circle\",\r\n    \"clipPath\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"feBlend\",\r\n    \"feColorMatrix\",\r\n    \"feComponentTransfer\",\r\n    \"feComposite\",\r\n    \"feConvolveMatrix\",\r\n    \"feDiffuseLighting\",\r\n    \"feDisplacementMap\",\r\n    \"feDistantLight\",\r\n    \"feDropShadow\",\r\n    \"feFlood\",\r\n    \"feFuncA\",\r\n    \"feFuncB\",\r\n    \"feFuncG\",\r\n    \"feFuncR\",\r\n    \"feGaussianBlur\",\r\n    \"feImage\",\r\n    \"feMerge\",\r\n    \"feMergeNode\",\r\n    \"feMorphology\",\r\n    \"feOffset\",\r\n    \"fePointLight\",\r\n    \"feSpecularLighting\",\r\n    \"feSpotLight\",\r\n    \"feTile\",\r\n    \"feTurbulence\",\r\n    \"filter\",\r\n    \"foreignObject\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"linearGradient\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"radialGradient\",\r\n    \"rect\",\r\n    \"script\",\r\n    \"set\",\r\n    \"stop\",\r\n    \"style\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"text\",\r\n    \"textPath\",\r\n    \"title\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n]);\r\nexport const MATH_TAGS = new Set([\r\n    \"math\",\r\n    \"maction\",\r\n    \"maligngroup\",\r\n    \"malignmark\",\r\n    \"menclose\",\r\n    \"merror\",\r\n    \"mfenced\",\r\n    \"mfrac\",\r\n    \"mglyph\",\r\n    \"mi\",\r\n    \"mlabeledtr\",\r\n    \"mlongdiv\",\r\n    \"mmultiscripts\",\r\n    \"mn\",\r\n    \"mo\",\r\n    \"mover\",\r\n    \"mpadded\",\r\n    \"mphantom\",\r\n    \"mroot\",\r\n    \"mrow\",\r\n    \"ms\",\r\n    \"mscarries\",\r\n    \"mscarry\",\r\n    \"msgroup\",\r\n    \"msline\",\r\n    \"mspace\",\r\n    \"msqrt\",\r\n    \"msrow\",\r\n    \"mstack\",\r\n    \"mstyle\",\r\n    \"msub\",\r\n    \"msup\",\r\n    \"msubsup\",\r\n    \"mtable\",\r\n    \"mtd\",\r\n    \"mtext\",\r\n    \"mtr\",\r\n    \"munder\",\r\n    \"munderover\",\r\n]);\r\n\r\nexport const MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\r\n\r\nexport const CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\r\n","import { isPlainObject } from \"./utils/general\";\r\nexport const IS_NON_DIMENSIONAL =\r\n    /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\r\n\r\nexport function styleObjectToString(\r\n    style: Record<string, string | number>\r\n): string {\r\n    const newStyles: string[] = [];\r\n\r\n    for (const key in style) {\r\n        const value = style[key];\r\n        const cssKey = key.replace(/([A-Z])/g, \"-$1\").toLowerCase(); // CamelCase to kebab-case\r\n\r\n        if (typeof value != \"number\" || IS_NON_DIMENSIONAL.test(cssKey)) {\r\n            newStyles.push(`${cssKey}: ${value};`); // Convert numbers to strings with px suffix\r\n        } else {\r\n            newStyles.push(`${cssKey}: ${value}px;`); // Convert numbers to strings with px suffix\r\n        }\r\n    }\r\n    return newStyles.join(\" \");\r\n}\r\n\r\nexport function preprocessStyle(\r\n    style: Record<string, any>\r\n): Record<string, string | number> {\r\n    const processedStyle: Record<string, string | number> = {};\r\n\r\n    for (const key in style) {\r\n        const value = style[key];\r\n        // Handle nested styles\r\n        if (typeof value === \"object\" && value !== null) {\r\n            console.warn(`Nested styles not allowed for ${key}`);\r\n            continue; // Skip nested styles\r\n        }\r\n\r\n        // Remove falsy values\r\n        if (\r\n            value === null ||\r\n            value === undefined ||\r\n            value === false ||\r\n            value === \"\"\r\n        ) {\r\n            continue;\r\n        }\r\n\r\n        // Otherwise, add to processed style\r\n        processedStyle[key] = value;\r\n    }\r\n\r\n    return processedStyle;\r\n}\r\n\r\nexport function isValidStyle(style: any) {\r\n    return isPlainObject(style) || typeof style === \"string\";\r\n}\r\n\r\nexport function applyMoves<T>(\r\n    arr: T[],\r\n    moves: Record<string, { from: number; to: number }>\r\n): T[] {\r\n    const n = arr.length;\r\n    // Create an array for the final result (we use undefined as a marker)\r\n    const result: (T | undefined)[] = new Array(n).fill(undefined);\r\n    // Keep track of which indices in the original array are moved.\r\n    const movedFrom = new Set<number>();\r\n\r\n    // First, place all moved elements at their target positions.\r\n    // (For a swap both targets will be filled by the respective moves.)\r\n    for (const key in moves) {\r\n        const { from, to } = moves[key];\r\n        // You can optionally ignore moves that are no-ops (from === to)\r\n        if (from === to) continue;\r\n        result[to] = arr[from];\r\n        movedFrom.add(from);\r\n    }\r\n\r\n    // Next, fill in the \"gaps\" with the unmoved elements,\r\n    // preserving their original order.\r\n    let fillIndex = 0; // current position in `result` to fill\r\n    for (let i = 0; i < n; i++) {\r\n        // Skip any element that was moved.\r\n        if (movedFrom.has(i)) continue;\r\n\r\n        // Advance fillIndex until we find an empty slot in result.\r\n        while (fillIndex < n && result[fillIndex] !== undefined) {\r\n            fillIndex++;\r\n        }\r\n        if (fillIndex < n) {\r\n            result[fillIndex] = arr[i];\r\n            fillIndex++;\r\n        }\r\n    }\r\n\r\n    return result as T[];\r\n}\r\n\r\n/**\r\n * Computes the indices of the longest increasing subsequence in the given array.\r\n * @param arr - An array of numbers.\r\n * @returns An array of indices representing the longest increasing subsequence.\r\n *\r\n * Time Complexity: O(n log n)\r\n */\r\nexport function longestIncreasingSubsequenceIndices(arr: number[]): number[] {\r\n    const n = arr.length;\r\n    const predecessors = new Array(n).fill(-1); // Track the previous index for each element in the subsequence.\r\n    const lisIndices: number[] = []; // Stores indices of the smallest tail for all increasing subsequences of each length.\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        const x = arr[i];\r\n\r\n        // Binary search for the insertion point in lisIndices.\r\n        let low = 0;\r\n        let high = lisIndices.length;\r\n        while (low < high) {\r\n            const mid = Math.floor((low + high) / 2);\r\n            if (arr[lisIndices[mid]] < x) {\r\n                low = mid + 1;\r\n            } else {\r\n                high = mid;\r\n            }\r\n        }\r\n\r\n        // If low is at the end, extend lisIndices; otherwise, update the tail value.\r\n        if (low === lisIndices.length) {\r\n            lisIndices.push(i);\r\n        } else {\r\n            lisIndices[low] = i;\r\n        }\r\n\r\n        // Set the predecessor of arr[i] (if low is not the start of a subsequence).\r\n        predecessors[i] = low > 0 ? lisIndices[low - 1] : -1;\r\n    }\r\n\r\n    // Reconstruct the longest increasing subsequence using the predecessors.\r\n    const lis: number[] = [];\r\n    let k = lisIndices.length > 0 ? lisIndices[lisIndices.length - 1] : -1;\r\n    for (let i = lisIndices.length - 1; i >= 0; i--) {\r\n        lis[i] = k;\r\n        k = predecessors[k];\r\n    }\r\n    return lis;\r\n}\r\n","import { isValidStyle, preprocessStyle, styleObjectToString } from \"../lib\";\r\nimport { setReactiveAttributes } from \"../signals/batch\";\r\nimport { reactiveAttribute } from \"../signals/signal\";\r\nimport { SVG_NAMESPACE } from \"./constants\";\r\n\r\nexport function setStyle(\r\n    style: Record<string, string | number> | string,\r\n    dom: HTMLElement\r\n) {\r\n    if (!isValidStyle(style))\r\n        throw new Error(\"Style attribute must be a plain object or a string\");\r\n\r\n    if (typeof style === \"string\") {\r\n        dom.setAttribute(\"style\", style);\r\n    } else {\r\n        const processedStyle = preprocessStyle(style);\r\n\r\n        dom.setAttribute(\"style\", styleObjectToString(processedStyle));\r\n    }\r\n}\r\n\r\n// handles setting the reactive attributes returned from a reactiveFunction\r\nexport function setReactiveAttribute(\r\n    reactiveFunction: any,\r\n    name: string,\r\n    dom: HTMLElement,\r\n    namespace?: string\r\n) {\r\n    reactiveFunction.__propName = name;\r\n    // registers the function in corresponding signal\r\n    const val = reactiveAttribute(reactiveFunction);\r\n    if (val === null || val === undefined || val === false) {\r\n        return;\r\n    }\r\n\r\n    setAttribute(name, val, dom, namespace);\r\n    // track this using signals if the function depended on any signal\r\n    if (reactiveFunction.__signals)\r\n        setReactiveAttributes(reactiveFunction, dom);\r\n}\r\n\r\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\r\n\r\nexport function setAttribute(\r\n    name: string,\r\n    value: any,\r\n    dom: HTMLElement,\r\n    namespace?: string\r\n) {\r\n    if (name == \"style\") {\r\n        setStyle(value, dom);\r\n        return;\r\n    }\r\n    if (name[0] === \"o\" && name[1] === \"n\" && typeof value === \"function\") {\r\n        const useCapture = name != (name = name.replace(CAPTURE_REGEX, \"$1\"));\r\n\r\n        if (\r\n            name.toLowerCase() in dom ||\r\n            name == \"onFocusOut\" ||\r\n            name == \"onFocusIn\" ||\r\n            name === \"onGotPointerCapture\" ||\r\n            name === \"onLostPointerCapture\"\r\n        )\r\n            name = name.toLowerCase().slice(2);\r\n        else name = name.slice(2);\r\n        // handle eventListeners\r\n        dom.addEventListener(name, value, useCapture);\r\n        return;\r\n    }\r\n\r\n    if (namespace === SVG_NAMESPACE) {\r\n        name = name.replace(/xlink(H|:h)/, \"h\").replace(/sName$/, \"s\");\r\n    }\r\n    // For certain properties that exist on the dom element,\r\n    // attempt to set them directly.\r\n    else if (\r\n        name !== \"width\" &&\r\n        name !== \"height\" &&\r\n        name !== \"href\" &&\r\n        name !== \"list\" &&\r\n        name !== \"form\" &&\r\n        name !== \"tabIndex\" &&\r\n        name !== \"download\" &&\r\n        name !== \"rowSpan\" &&\r\n        name !== \"colSpan\" &&\r\n        name !== \"role\" &&\r\n        name !== \"popover\" &&\r\n        name in dom\r\n    ) {\r\n        try {\r\n            // Set the property directly on the DOM element.\r\n            if (name === \"value\" && dom.tagName === \"SELECT\") {\r\n                setTimeout(() => {\r\n                    dom[name] = value == null ? \"\" : value;\r\n                });\r\n            } else {\r\n                dom[name] = value == null ? \"\" : value;\r\n            }\r\n            // console.log(dom[name], dom);\r\n\r\n            // We simply return after setting the property.\r\n            return;\r\n        } catch (e) {\r\n            // If setting the property fails, fall through to update attributes.\r\n        }\r\n    }\r\n\r\n    if (value != null && (value !== false || name[4] === \"-\")) {\r\n        // For most attributes, if the value is valid, set the attribute.\r\n        // Special case: for \"popover\", if value is true, set attribute to an empty string.\r\n\r\n        dom.setAttribute(\r\n            name,\r\n            name === \"popover\" && value === true ? \"\" : value\r\n        );\r\n    }\r\n}\r\n","import {\r\n    addEffect,\r\n    addSignal,\r\n    cleanUp,\r\n    cleanUpWFiber,\r\n    getCurrentFC,\r\n} from \"../rendering/functionalComponents\";\r\nimport { Fiber } from \"../types\";\r\nimport { isPlainObject, isPrimitive } from \"../utils/general\";\r\nimport { batchUpdate } from \"./batch\";\r\n\r\nlet currentReactiveFunction: any = null;\r\nlet currentEffect: any = null;\r\n\r\nfunction addSignalToReactiveFunction(signal: any) {\r\n    if (!currentReactiveFunction.__signals) {\r\n        currentReactiveFunction.__signals = new Set();\r\n    }\r\n    currentReactiveFunction.__signals.add(signal);\r\n}\r\nfunction addSignalToEffect(signal: any) {\r\n    if (!currentEffect.__signals) currentEffect.__signals = new Set();\r\n    currentEffect.__signals.add(signal);\r\n}\r\n\r\nexport function reactive(fn: Function) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"reactive takes a render function as the argument\");\r\n\r\n    currentReactiveFunction = fn;\r\n    const retVal = fn();\r\n    currentReactiveFunction = null;\r\n    if (\r\n        !isPrimitive(retVal) &&\r\n        isPlainObject(retVal) &&\r\n        !retVal.type &&\r\n        !retVal.props &&\r\n        !retVal.props?.children\r\n    )\r\n        throw new Error(\r\n            \"Reactive value must be primitive or functional component, got: \" +\r\n                typeof retVal\r\n        );\r\n    return retVal;\r\n}\r\nexport function reactiveAttribute(fn: Function) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"reactive takes a render function as the argument\");\r\n\r\n    currentReactiveFunction = fn;\r\n    const retVal = fn();\r\n    currentReactiveFunction = null;\r\n\r\n    return retVal;\r\n}\r\nexport function createEffect(fn: Function) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"createEffect takes a effect function as the argument\");\r\n\r\n    addEffect(fn);\r\n    if (!getCurrentFC()) runEffect(fn);\r\n}\r\n\r\nexport function runEffect(effect: Function, fiber?: Fiber) {\r\n    if (typeof effect !== \"function\") return;\r\n\r\n    currentEffect = effect;\r\n\r\n    const effectCleanup = effect();\r\n\r\n    if (currentEffect.__signals && typeof effectCleanup === \"function\") {\r\n        currentEffect.__cleanup = effectCleanup;\r\n    }\r\n\r\n    if (\r\n        !currentEffect.__signals &&\r\n        effectCleanup &&\r\n        typeof effectCleanup === \"function\"\r\n    ) {\r\n        // which means this effect does not have any signals associated with so its just a cleanup function that we need to call when the component unmounts\r\n        if (!fiber) {\r\n            cleanUp(effectCleanup);\r\n        } else {\r\n            cleanUpWFiber(effectCleanup, fiber);\r\n        }\r\n    }\r\n\r\n    currentEffect = null;\r\n}\r\n\r\nfunction computed<T extends NormalSignal | any[] | Record<any, any>>(\r\n    fn: () => T\r\n) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"computed takes a function as the argument\");\r\n\r\n    let firstRun = getCurrentFC() !== null;\r\n    currentEffect = () => {\r\n        if (firstRun) {\r\n            firstRun = false;\r\n            return;\r\n        }\r\n        signal.update(fn());\r\n    };\r\n\r\n    addEffect(currentEffect);\r\n\r\n    const val = fn();\r\n\r\n    // @ts-expect-error - Type assertion for signal\r\n    const signal = createSignal<T>(val);\r\n\r\n    currentEffect = null;\r\n    return {\r\n        get value() {\r\n            return signal.value;\r\n        },\r\n    };\r\n}\r\n\r\ntype PromiseOverload<T> =\r\n    | { status: \"pending\"; data: null; error: null }\r\n    | { status: \"resolved\"; data: T; error: null }\r\n    | { status: \"rejected\"; data: null; error: Error };\r\n\r\nexport function createPromise<T>(fn: () => Promise<T>) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"createPromise takes a function as the argument\");\r\n    const promise = fn();\r\n\r\n    if (!(promise instanceof Promise)) {\r\n        throw new Error(\r\n            \"createPromise takes a function that returns a promise\"\r\n        );\r\n    }\r\n    const triggerSignal = createSignal<PromiseOverload<T>>({\r\n        status: \"pending\",\r\n        data: null,\r\n        error: null,\r\n    });\r\n\r\n    promise\r\n        .then((val) => {\r\n            triggerSignal.update((prev) => {\r\n                prev.data = val;\r\n                prev.status = \"resolved\";\r\n            });\r\n        })\r\n        .catch((err) => {\r\n            triggerSignal.update((prev) => {\r\n                prev.error = err;\r\n                prev.status = \"rejected\";\r\n            });\r\n        });\r\n\r\n    return {\r\n        get value() {\r\n            return triggerSignal.value;\r\n        },\r\n    };\r\n}\r\n\r\nexport class Ref<T extends EventTarget> {\r\n    current: T | null;\r\n    constructor(val: T | null) {\r\n        this.current = val;\r\n    }\r\n}\r\n\r\nexport function createRef<T extends EventTarget>() {\r\n    const ref = new Ref<T>(null);\r\n    return ref;\r\n}\r\n\r\n// const NonMutatingArrayMethods = [\r\n//     \"constructor\",\r\n//     \"concat\",\r\n//     \"every\",\r\n//     \"filter\",\r\n//     \"find\",\r\n//     \"findIndex\",\r\n//     \"flat\",\r\n//     \"flatMap\",\r\n//     \"forEach\",\r\n//     \"includes\",\r\n//     \"indexOf\",\r\n//     \"join\",\r\n//     \"map\",\r\n//     \"reduce\",\r\n//     \"reduceRight\",\r\n//     \"slice\",\r\n//     \"some\",\r\n//     \"toLocaleString\",\r\n//     \"toString\",\r\n// ];\r\nconst MutatingMethods = [\r\n    \"push\",\r\n    \"pop\",\r\n    \"unshift\",\r\n    \"shift\",\r\n    \"splice\",\r\n    \"fill\",\r\n    \"copyWithin\",\r\n    \"sort\",\r\n    \"reverse\",\r\n];\r\n\r\ntype DeepReadonly<T> = {\r\n    readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\r\n};\r\n\r\n/**\r\n *\r\n * Base class for signals.\r\n */\r\nexport abstract class BaseSignal<T> {\r\n    protected _val: T;\r\n    protected deps: Set<Function>;\r\n    protected isNotified: boolean = false;\r\n\r\n    constructor(val: T) {\r\n        this._val = val;\r\n        this.deps = new Set();\r\n    }\r\n\r\n    protected notify() {\r\n        if (this.isNotified) return;\r\n\r\n        if (this.deps.size !== 0) this.isNotified = true;\r\n\r\n        this.deps.forEach((dep) => {\r\n            batchUpdate(() => {\r\n                // Reset the flag before calling the dependency\r\n                this.isNotified = false;\r\n                return dep;\r\n            });\r\n        });\r\n    }\r\n\r\n    public removeDep(fn: Function) {\r\n        this.deps.delete(fn);\r\n    }\r\n\r\n    public clearDeps() {\r\n        this.deps.clear();\r\n    }\r\n\r\n    abstract get value(): T | DeepReadonly<T>;\r\n\r\n    abstract update(val: T | ((prev: T) => T)): void;\r\n}\r\n\r\ntype NormalSignal = boolean | string | number | undefined | null | Error;\r\n/**\r\n * Signal for primitive types.\r\n */\r\nexport class PrimitiveSignal<T extends NormalSignal> extends BaseSignal<T> {\r\n    constructor(val: T) {\r\n        if (!isPrimitive(val)) {\r\n            throw new Error(\r\n                \"Invalid type for PrimitiveSignal. Valid types: [boolean, string, number, undefined, null]\"\r\n            );\r\n        }\r\n        super(val);\r\n    }\r\n\r\n    get value(): T {\r\n        if (currentEffect) {\r\n            this.deps.add(currentEffect);\r\n            addSignalToEffect(this);\r\n        }\r\n        if (currentReactiveFunction) {\r\n            this.deps.add(currentReactiveFunction);\r\n\r\n            addSignalToReactiveFunction(this);\r\n        }\r\n        // (Optional) debug logging:\r\n        // console.log(this.deps);\r\n        return this._val;\r\n    }\r\n\r\n    public update(val: T | ((prev: T) => T)) {\r\n        if (typeof val === \"function\") {\r\n            const newVal = val(this._val);\r\n            if (!isPrimitive(newVal)) {\r\n                throw new Error(\r\n                    \"Invalid type for PrimitiveSignal. Valid types: [boolean, string, number, undefined, null]\"\r\n                );\r\n            }\r\n            if (newVal === this._val) return;\r\n            this._val = newVal;\r\n            this.notify();\r\n        } else {\r\n            if (!isPrimitive(val)) {\r\n                throw new Error(\r\n                    \"Invalid type for PrimitiveSignal. Valid types: [boolean, string, number, undefined, null]\"\r\n                );\r\n            }\r\n            if (val === this._val) return;\r\n\r\n            this._val = val;\r\n\r\n            this.notify();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Signal for arrays.\r\n */\r\nexport class ArraySignal<T extends any[]> extends BaseSignal<T> {\r\n    private updateCalled: boolean = false;\r\n\r\n    constructor(val: T) {\r\n        if (!Array.isArray(val)) {\r\n            throw new Error(\r\n                \"Invalid type for ArraySignal; value must be an array\"\r\n            );\r\n        }\r\n        // Call the base constructor with a proxy-wrapped array.\r\n        super(val);\r\n        this._val = this.createProxy(val);\r\n    }\r\n\r\n    private createProxy(val: T): T {\r\n        return new Proxy(val, {\r\n            get: (target, prop) => {\r\n                const value = target[prop as any];\r\n                // If a function is accessed, wrap it to trigger notifications on mutation.\r\n\r\n                if (typeof value === \"function\") {\r\n                    if (\r\n                        MutatingMethods.includes(String(prop)) &&\r\n                        !this.updateCalled\r\n                    ) {\r\n                        throw new Error(\r\n                            \"Cannot set a value on an array signal, use the update method for updating the array.\"\r\n                        );\r\n                    }\r\n\r\n                    return (...args: any[]) => {\r\n                        const result = value.apply(target, args);\r\n                        // Notify if the method is mutating.\r\n                        if (MutatingMethods.includes(String(prop))) {\r\n                            this.notify();\r\n                        }\r\n                        return result;\r\n                    };\r\n                }\r\n                return value;\r\n            },\r\n            set: (target, prop, newValue) => {\r\n                if (!this.updateCalled) {\r\n                    throw new Error(\r\n                        \"Cannot set a value on an array signal, use the update method for updating the array.\"\r\n                    );\r\n                }\r\n                target[prop as any] = newValue;\r\n                this.notify();\r\n                return true;\r\n            },\r\n        });\r\n    }\r\n\r\n    get value(): DeepReadonly<T> {\r\n        if (currentEffect) {\r\n            this.deps.add(currentEffect);\r\n            addSignalToEffect(this);\r\n        }\r\n        if (currentReactiveFunction) {\r\n            this.deps.add(currentReactiveFunction);\r\n            addSignalToReactiveFunction(this);\r\n        }\r\n\r\n        return this._val;\r\n    }\r\n\r\n    public update(val: T | ((prev: T) => void)) {\r\n        this.updateCalled = true;\r\n        if (typeof val === \"function\") {\r\n            val(this._val);\r\n        } else {\r\n            if (!Array.isArray(val)) {\r\n                throw new Error(\r\n                    \"Invalid type for ArraySignal; value must be an array\"\r\n                );\r\n            }\r\n            if (val === this._val) return;\r\n\r\n            this._val = this.createProxy(val);\r\n\r\n            this.notify();\r\n        }\r\n        this.updateCalled = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Signal for plain objects.\r\n */\r\nexport class ObjectSignal<T extends Record<any, any>> extends BaseSignal<T> {\r\n    private updateCalled: boolean = false;\r\n    constructor(val: T) {\r\n        if (!isPlainObject(val)) {\r\n            throw new Error(\r\n                \"Invalid type for ObjectSignal; value must be a plain object\"\r\n            );\r\n        }\r\n        super(val);\r\n        this._val = this.createProxy(val);\r\n    }\r\n    private createInternalArrayProxy<A extends any[]>(val: A): A {\r\n        return new Proxy(val, {\r\n            get: (target, prop) => {\r\n                const value = target[prop as any];\r\n                // If a function is accessed, wrap it to trigger notifications on mutation.\r\n                if (typeof value === \"function\") {\r\n                    if (\r\n                        !this.updateCalled &&\r\n                        MutatingMethods.includes(String(prop))\r\n                    ) {\r\n                        throw new Error(\r\n                            \"Cannot set a value on an object signal, use the update method for updating the object.\"\r\n                        );\r\n                    }\r\n\r\n                    return (...args: any[]) => {\r\n                        const result = value.apply(target, args);\r\n                        // Notify if the method is mutating.\r\n                        if (MutatingMethods.includes(String(prop))) {\r\n                            this.notify();\r\n                        }\r\n                        return result;\r\n                    };\r\n                }\r\n                return value;\r\n            },\r\n            set: (target, prop, newValue) => {\r\n                if (!this.updateCalled) {\r\n                    throw new Error(\r\n                        \"Cannot set a value on an object signal, use the update method for updating the object.\"\r\n                    );\r\n                }\r\n                target[prop as any] = newValue;\r\n                this.notify();\r\n                return true;\r\n            },\r\n        });\r\n    }\r\n    private createProxy(val: T): T {\r\n        return new Proxy(val, {\r\n            get: (target, prop) => {\r\n                const value = target[prop as any];\r\n                if (Array.isArray(value)) {\r\n                    // @ts-expect-error\r\n                    target[prop as any] =\r\n                        this.createInternalArrayProxy<typeof value>(value);\r\n\r\n                    return target[prop as any];\r\n                }\r\n                // console.log(\"get\", target, prop, value);\r\n                return value;\r\n            },\r\n            set: (target, prop, newValue) => {\r\n                if (!this.updateCalled) {\r\n                    throw new Error(\r\n                        \"Cannot set a value on an object signal, use the update method for updating the object.\"\r\n                    );\r\n                }\r\n                // Do not allow functions to be set as values.\r\n                if (typeof newValue === \"function\") return false;\r\n                // For nested objects, wrap them as well.\r\n                if (typeof newValue === \"object\" && newValue !== null) {\r\n                    newValue = this.createProxy(newValue);\r\n                }\r\n                if (newValue === target[prop as any]) return true;\r\n\r\n                // @ts-expect-error\r\n                target[prop as any] = newValue;\r\n\r\n                this.notify();\r\n\r\n                return true;\r\n            },\r\n            deleteProperty: (target, prop) => {\r\n                const result = delete target[prop as any];\r\n                this.notify();\r\n                return result;\r\n            },\r\n        });\r\n    }\r\n\r\n    get value(): DeepReadonly<T> {\r\n        if (currentEffect) {\r\n            this.deps.add(currentEffect);\r\n            addSignalToEffect(this);\r\n        }\r\n        if (currentReactiveFunction) {\r\n            this.deps.add(currentReactiveFunction);\r\n            addSignalToReactiveFunction(this);\r\n        }\r\n        return this._val;\r\n    }\r\n\r\n    public update(val: T | ((prev: T) => void)) {\r\n        this.updateCalled = true;\r\n        if (typeof val === \"function\") {\r\n            val(this._val);\r\n        } else {\r\n            if (!isPlainObject(val)) {\r\n                throw new Error(\r\n                    \"Invalid type for ObjectSignal; value must be a plain object\"\r\n                );\r\n            }\r\n            if (val === this._val) return;\r\n            this._val = this.createProxy(val);\r\n            this.notify();\r\n        }\r\n        this.updateCalled = false;\r\n    }\r\n}\r\n\r\nexport interface PublicSignal<T> {\r\n    readonly value: DeepReadonly<T>;\r\n    update(val: T | ((prev: T) => T)): void;\r\n}\r\n\r\nexport interface PublicArraySignal<T extends any[]> extends PublicSignal<T> {\r\n    update(val: T | ((prev: T) => void)): void; // Mutation allowed\r\n}\r\n\r\nexport interface PublicObjectSignal<T extends Record<any, any>>\r\n    extends PublicSignal<T> {\r\n    update(val: T | ((prev: T) => void)): void; // Mutation allowed\r\n}\r\n/**\r\n * Overloaded factory function to create a signal.\r\n */\r\nfunction createSignal<T extends NormalSignal>(val: T): PublicSignal<T>;\r\nfunction createSignal<T extends any[]>(val: T): PublicArraySignal<T>;\r\nfunction createSignal<T extends Record<any, any>>(\r\n    val: T\r\n): PublicObjectSignal<T>;\r\n\r\nfunction createSignal<T extends NormalSignal | any[] | Record<any, any>>(\r\n    val: T\r\n) {\r\n    if (typeof val === \"function\") {\r\n        throw new Error(\"Functions cannot be used as signal value\");\r\n    }\r\n\r\n    if (typeof val === \"object\" && val !== null) {\r\n        if (Array.isArray(val)) {\r\n            const signal = new ArraySignal(val);\r\n            addSignal(signal);\r\n            return {\r\n                get value() {\r\n                    return signal.value;\r\n                },\r\n                update: signal.update.bind(signal) as typeof signal.update,\r\n            };\r\n        } else if (isPlainObject(val)) {\r\n            const signal = new ObjectSignal(val);\r\n            addSignal(signal);\r\n            return {\r\n                get value() {\r\n                    return signal.value;\r\n                },\r\n                update: signal.update.bind(signal) as typeof signal.update,\r\n            };\r\n        } else {\r\n            throw new Error(\r\n                \"Invalid type for signal initialization: \" + typeof val\r\n            );\r\n        }\r\n    } else if (isPrimitive(val)) {\r\n        const signal = new PrimitiveSignal(val);\r\n        addSignal(signal);\r\n        return {\r\n            get value() {\r\n                return signal.value;\r\n            },\r\n            update: signal.update.bind(signal) as typeof signal.update,\r\n        };\r\n    } else {\r\n        throw new Error(\r\n            \"Invalid type for signal initialization: \" + typeof val\r\n        );\r\n    }\r\n}\r\n\r\nexport { computed, createSignal };\r\n","import { updateDomProp } from \"../rendering/createElements\";\r\nimport { updateFiber } from \"../rendering/render\";\r\nimport { Fiber } from \"../types\";\r\n\r\nlet scheduled = false;\r\nconst batch = new Set<Function>();\r\nconst depset = new Set();\r\nconst reactiveFiberMap = new WeakMap();\r\nconst domAttributeMap = new WeakMap<Function, HTMLElement | Text>();\r\n\r\nexport function batchUpdate(cb: Function) {\r\n    batch.add(cb);\r\n    if (!scheduled) {\r\n        scheduled = true;\r\n        queueMicrotask(() => {\r\n            // console.log(\"Current batch has: \", batch.size, \" Functions\");\r\n\r\n            batch.forEach((fn) => {\r\n                const dep = fn();\r\n                if (depset.has(dep)) {\r\n                    return;\r\n                }\r\n                depset.add(dep);\r\n                // effects and reactive nodes\r\n                if (dep.__cleanup && typeof dep.__cleanup === \"function\") {\r\n                    dep.__cleanup();\r\n                    dep.__cleanup = null;\r\n                }\r\n\r\n                const val = dep();\r\n\r\n                if (typeof val === \"function\") {\r\n                    dep.__cleanup = val;\r\n                }\r\n                // console.log(dep, \"dep\");\r\n                if (reactiveFiberMap.has(dep)) {\r\n                    // for updating reactive nodes\r\n                    const fiber = reactiveFiberMap.get(dep);\r\n                    if (fiber) {\r\n                        // console.log(\"dep\", fiber);\r\n                        updateFiber(fiber, val);\r\n                    }\r\n                }\r\n                if (domAttributeMap.has(dep)) {\r\n                    // for updating reactive nodes\r\n                    const dom = domAttributeMap.get(dep);\r\n                    if (dom && dep.__propName) {\r\n                        updateDomProp(dep.__propName, dom, val);\r\n                    }\r\n                }\r\n            });\r\n            depset.clear();\r\n            batch.clear();\r\n            scheduled = false;\r\n        });\r\n    }\r\n}\r\n\r\nexport function setReactiveFunction(fn: Function, fiber: Fiber) {\r\n    reactiveFiberMap.set(fn, fiber);\r\n}\r\nexport function setReactiveAttributes(fn: Function, dom: HTMLElement | Text) {\r\n    // console.log(\"reactive attrubite\", fn);\r\n    domAttributeMap.set(fn, dom);\r\n}\r\nexport function clearReactiveAttributes(fn: any) {\r\n    domAttributeMap.delete(fn);\r\n\r\n    const signals = fn.__signals;\r\n    if (signals) {\r\n        for (const signal of signals) {\r\n            signal.removeDep(fn);\r\n        }\r\n        fn.__signals = null;\r\n    }\r\n}\r\n\r\nexport function clearReactiveFunction(fn: Function) {\r\n    reactiveFiberMap.delete(fn);\r\n    // @ts-expect-error\r\n    const signals = fn.__signals;\r\n    if (signals) {\r\n        for (const signal of signals) {\r\n            signal.removeDep(fn);\r\n        }\r\n        // @ts-expect-error\r\n        fn.__signals = null;\r\n    }\r\n}\r\n\r\nexport function deleteReactiveFunction(fn: Function) {\r\n    reactiveFiberMap.delete(fn);\r\n}\r\n","import { isValidStyle, preprocessStyle, styleObjectToString } from \"../lib\";\r\nimport { setReactiveAttributes } from \"../signals/batch\";\r\nimport { reactive, reactiveAttribute, Ref } from \"../signals/signal\";\r\nimport {\r\n    Fiber,\r\n    FiberChildren,\r\n    NodeType,\r\n    Props,\r\n    RenderFunction,\r\n} from \"../types\";\r\nimport { isPrimitive } from \"../utils/general\";\r\nimport {\r\n    MATH_NAMESPACE,\r\n    MATH_TAGS,\r\n    SVG_NAMESPACE,\r\n    SVG_TAGS,\r\n} from \"./constants\";\r\nimport { setAttribute, setReactiveAttribute } from \"./props\";\r\nexport const FRAGMENT_SYMBOL = Symbol(\"FRAGMENT\");\r\n\r\nexport function createElement(\r\n    type: any,\r\n    props: object | null,\r\n    ...children: any[]\r\n): Fiber | FiberChildren {\r\n    if (type === \"FRAGMENT\") {\r\n        const fragments = createChildren(children);\r\n        fragments[FRAGMENT_SYMBOL] = true;\r\n\r\n        return fragments;\r\n    }\r\n    // @ts-expect-error\r\n    return {\r\n        type,\r\n        props: {\r\n            ...props,\r\n            children: createChildren(children),\r\n        },\r\n    };\r\n}\r\n\r\nexport function createChildren(children: FiberChildren): FiberChildren {\r\n    // @ts-expect-error\r\n    return children\r\n        .map((child) => {\r\n            if (typeof child === \"object\") {\r\n                if (Array.isArray(child)) {\r\n                    return createChildren(child);\r\n                }\r\n                if (child === null) {\r\n                    return createTextChildren(\"\");\r\n                }\r\n                if (!child.type || !child.props) {\r\n                    throw new Error(\r\n                        \"Invalid type for a dom node, found \" + child\r\n                    );\r\n                }\r\n                return child;\r\n            } else if (typeof child === \"function\") {\r\n                const val = reactive(child);\r\n                if (isPrimitive(val)) {\r\n                    return createSignalChild(\r\n                        \"TEXT_CHILD\",\r\n                        {\r\n                            nodeValue:\r\n                                val !== undefined &&\r\n                                val !== null &&\r\n                                val !== false\r\n                                    ? String(val)\r\n                                    : \"\",\r\n                            children: [],\r\n                        },\r\n                        child\r\n                    );\r\n                } else if (Array.isArray(val)) {\r\n                    // console.log(createChildren(val));\r\n                    const isFragment = val[FRAGMENT_SYMBOL];\r\n                    return createSignalChild(\r\n                        \"FRAGMENT\",\r\n                        { children: isFragment ? val : createChildren(val) },\r\n                        child\r\n                    );\r\n                } else if (!val.type || !val.props) {\r\n                    throw new Error(\r\n                        \"Invalid type for a dom node, found \" + val\r\n                    );\r\n                }\r\n                return createSignalChild(val.type, val.props, child);\r\n            } else {\r\n                return createTextChildren(child);\r\n            }\r\n        })\r\n        .flat();\r\n}\r\n\r\nexport function createTextChildren(text: any): Fiber {\r\n    // @ts-expect-error\r\n    return {\r\n        type: \"TEXT_CHILD\",\r\n        props: {\r\n            nodeValue:\r\n                text !== null && text !== undefined && text !== false\r\n                    ? String(text)\r\n                    : \"\",\r\n            children: [],\r\n        },\r\n    };\r\n}\r\n\r\nfunction createSignalChild(\r\n    type: NodeType,\r\n    props: Props,\r\n    renderFunction: RenderFunction\r\n) {\r\n    return {\r\n        type,\r\n        renderFunction,\r\n        props,\r\n    };\r\n}\r\n\r\nfunction isProperty(key: string) {\r\n    return key !== \"children\" && key !== \"key\" && key !== \"ref\";\r\n}\r\n\r\nexport function createNode(element: Fiber): HTMLElement | Text {\r\n    let namespace: string | null = null;\r\n\r\n    if (SVG_TAGS.has(element.type as string)) namespace = SVG_NAMESPACE;\r\n    else if (MATH_TAGS.has(element.type as string)) namespace = MATH_NAMESPACE;\r\n\r\n    const dom =\r\n        element.type === \"TEXT_CHILD\"\r\n            ? document.createTextNode(\"\")\r\n            : namespace\r\n            ? document.createElementNS(\r\n                  namespace,\r\n                  // @ts-expect-error\r\n                  element.type,\r\n                  element.props.is && element.props\r\n              )\r\n            : // @ts-expect-error\r\n              document.createElement(element.type);\r\n\r\n    if (!element.props) return dom as HTMLElement | Text;\r\n\r\n    if (\r\n        element.props.ref &&\r\n        element.props.ref instanceof Ref &&\r\n        dom instanceof HTMLElement\r\n    ) {\r\n        element.props.ref.current = dom;\r\n    }\r\n\r\n    for (const name in element.props) {\r\n        if (!isProperty(name)) {\r\n            continue;\r\n        }\r\n        const value = element.props[name];\r\n        if (typeof value === \"function\" && name[0] !== \"o\" && name[1] !== \"n\") {\r\n            // @ts-expect-error\r\n            setReactiveAttribute(value, name, dom, namespace);\r\n        } else {\r\n            // @ts-expect-error\r\n            setAttribute(name, value, dom, namespace);\r\n        }\r\n    }\r\n\r\n    return dom as HTMLElement | Text;\r\n}\r\n\r\nexport function updateDomProp(\r\n    prop: string,\r\n    dom: HTMLElement | Text,\r\n    value: any\r\n) {\r\n    if (value == null || prop === \"key\") return;\r\n\r\n    // @ts-expect-error\r\n    setAttribute(prop, value, dom);\r\n}\r\n\r\nexport const FRAGMENT = \"FRAGMENT\";\r\n","import {\r\n    clearReactiveAttributes,\r\n    clearReactiveFunction,\r\n    setReactiveFunction,\r\n} from \"../signals/batch\";\r\nimport { BaseSignal, Ref } from \"../signals/signal\";\r\nimport { Fiber, FiberChildren } from \"../types\";\r\nimport { isPrimitive } from \"../utils/general\";\r\nimport { CAPTURE_REGEX } from \"./constants\";\r\nimport {\r\n    FRAGMENT_SYMBOL,\r\n    createChildren,\r\n    createNode,\r\n    createTextChildren,\r\n} from \"./createElements\";\r\nimport {\r\n    cleanUpFC,\r\n    clearCurrentFC,\r\n    runAllEffects,\r\n    setCurrentFC,\r\n} from \"./functionalComponents\";\r\n\r\nexport function render(element: Fiber, container: HTMLElement) {\r\n    rootContainer = container;\r\n    const fragment = document.createDocumentFragment();\r\n    rootFragment = fragment;\r\n    const rootFiber: Fiber = {\r\n        type: \"div\",\r\n        props: {\r\n            children: [element],\r\n        },\r\n        // @ts-expect-error\r\n        dom: fragment,\r\n    };\r\n    // console.log(element.type(element.props));\r\n    element.parent = rootFiber;\r\n    elements.push(element);\r\n    requestIdleCallback(workLoop);\r\n\r\n    // container.appendChild(fragment);\r\n}\r\n\r\nfunction commitRootFragment() {\r\n    if (rootFragment && rootContainer) {\r\n        rootContainer.appendChild(rootFragment);\r\n        // const endTime = performance.now();\r\n        // console.log(`Render time: ${endTime - startTime}ms`);\r\n    }\r\n}\r\n\r\nlet elements: Fiber[] = [];\r\nlet rootContainer: HTMLElement | null = null;\r\nlet rootFragment: DocumentFragment | null = null;\r\n// let startTime = -1;\r\nlet effectQueue: Fiber[] = [];\r\n\r\nfunction processEffectQueue() {\r\n    for (let i = 0; i < effectQueue.length; i++) {\r\n        const fiber = effectQueue[i];\r\n        runAllEffects(fiber);\r\n    }\r\n    effectQueue.length = 0;\r\n}\r\n\r\nfunction workLoop(deadline: IdleDeadline) {\r\n    // if (startTime === -1) startTime = performance.now();\r\n\r\n    processEffectQueue();\r\n    let shouldYield = false;\r\n    while (elements.length > 0 && !shouldYield) {\r\n        const element = elements.pop();\r\n        renderNode(element!);\r\n        shouldYield = deadline.timeRemaining() < 1;\r\n    }\r\n\r\n    if (elements.length == 0) {\r\n        commitRootFragment();\r\n\r\n        processEffectQueue();\r\n        return;\r\n    }\r\n    requestIdleCallback(workLoop);\r\n}\r\n\r\nfunction renderNode(fiber: Fiber) {\r\n    if (fiber.type === \"FRAGMENT\") {\r\n        const isArray = !fiber.props.children[FRAGMENT_SYMBOL];\r\n        let noKey = false;\r\n        for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n            fiber.props.children[i].parent = fiber;\r\n\r\n            if (\r\n                isArray &&\r\n                fiber.props.children[i].props.key === undefined &&\r\n                fiber.renderFunction\r\n            ) {\r\n                noKey = true;\r\n            }\r\n\r\n            elements.push(fiber.props.children[i]);\r\n        }\r\n        if (noKey) {\r\n            console.error(\"Array children must have a key attribute\");\r\n        }\r\n        // console.log(fiber.props.children);\r\n    } else if (typeof fiber.type === \"function\") {\r\n        setCurrentFC(fiber);\r\n\r\n        const children = fiber.type(fiber.props);\r\n        clearCurrentFC();\r\n\r\n        if (Array.isArray(children)) {\r\n            // which means that the FC returned a fragment\r\n            // console.log(children);\r\n            for (let i = children.length - 1; i >= 0; i--) {\r\n                children[i].parent = fiber;\r\n                elements.push(children[i]);\r\n            }\r\n            fiber.props.children = children;\r\n        } else {\r\n            children.parent = fiber;\r\n            fiber.props.children.push(children);\r\n            elements.push(children);\r\n        }\r\n        // queue to run its effects\r\n        effectQueue.push(fiber);\r\n    } else {\r\n        if (!fiber.dom) fiber.dom = createNode(fiber);\r\n        let fiberParent: Fiber | undefined = fiber.parent;\r\n        while (fiberParent && !fiberParent.dom) {\r\n            fiberParent = fiberParent.parent;\r\n        }\r\n        if (fiberParent) {\r\n            fiberParent.dom?.appendChild(fiber.dom);\r\n        }\r\n\r\n        for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n            fiber.props.children[i].parent = fiber;\r\n            elements.push(fiber.props.children[i]);\r\n        }\r\n    }\r\n    // console.log(fiber);\r\n    setRenderFunction(fiber);\r\n}\r\n\r\nfunction createFiber(fiber: Fiber) {\r\n    if (fiber.type === \"FRAGMENT\") {\r\n        const isFragment = fiber.props.children[FRAGMENT_SYMBOL];\r\n        if (isFragment) {\r\n            for (const child of fiber.props.children) {\r\n                child.parent = fiber;\r\n                createFiber(child);\r\n            }\r\n        } else {\r\n            let noKey = false;\r\n            for (const child of fiber.props.children) {\r\n                child.parent = fiber;\r\n                if (child.props.key === undefined) {\r\n                    noKey = true;\r\n                }\r\n                createFiber(child);\r\n            }\r\n            if (noKey) {\r\n                console.error(\"Array children must have a key attribute\");\r\n            }\r\n        }\r\n    } else if (typeof fiber.type !== \"function\") {\r\n        for (const child of fiber.props.children) {\r\n            child.parent = fiber;\r\n            createFiber(child);\r\n        }\r\n    }\r\n    // console.log(fiber);\r\n    setRenderFunction(fiber);\r\n}\r\nfunction commitFiber(\r\n    fiber: Fiber,\r\n    referenceNode?: Node,\r\n    replace?: boolean,\r\n    needCreation?: boolean,\r\n    customParent?: Node\r\n) {\r\n    if (fiber.type === \"FRAGMENT\") {\r\n        for (const child of fiber.props.children) {\r\n            if (needCreation) child.parent = fiber;\r\n            commitFiber(\r\n                child,\r\n                referenceNode,\r\n                replace,\r\n                needCreation,\r\n                customParent\r\n            );\r\n        }\r\n    } else if (typeof fiber.type === \"function\") {\r\n        setCurrentFC(fiber);\r\n\r\n        const children = fiber.type(fiber.props);\r\n        clearCurrentFC();\r\n\r\n        // console.log(\"commit FC\", children);\r\n        if (Array.isArray(children)) {\r\n            // which means that the FC returned a fragment\r\n            // console.log(children);\r\n            for (const child of children) {\r\n                child.parent = fiber;\r\n                commitFiber(child, referenceNode, replace, true, customParent);\r\n            }\r\n            fiber.props.children = children;\r\n        } else {\r\n            children.parent = fiber;\r\n            fiber.props.children.push(children);\r\n            commitFiber(children, referenceNode, replace, true, customParent);\r\n        }\r\n        // queue to run its effects at the end of current stack\r\n        queueMicrotask(() => {\r\n            runAllEffects(fiber);\r\n        });\r\n    } else {\r\n        if (!fiber.dom) fiber.dom = createNode(fiber);\r\n\r\n        if (referenceNode) {\r\n            if (replace)\r\n                referenceNode.parentElement?.replaceChild(\r\n                    fiber.dom,\r\n                    referenceNode\r\n                );\r\n            else\r\n                referenceNode.parentElement?.insertBefore(\r\n                    fiber.dom,\r\n                    referenceNode\r\n                );\r\n        } else {\r\n            let parentDom: Node | undefined = undefined;\r\n            if (customParent) {\r\n                parentDom = customParent;\r\n            } else {\r\n                let fiberParent: Fiber | undefined = fiber.parent;\r\n\r\n                while (fiberParent && !fiberParent.dom) {\r\n                    fiberParent = fiberParent.parent;\r\n                }\r\n                parentDom = fiberParent?.dom;\r\n            }\r\n            parentDom?.appendChild(fiber.dom);\r\n        }\r\n        for (const child of fiber.props.children) {\r\n            if (needCreation) child.parent = fiber;\r\n\r\n            commitFiber(child, undefined, undefined, needCreation, fiber.dom);\r\n        }\r\n    }\r\n    if (needCreation) {\r\n        setRenderFunction(fiber);\r\n    }\r\n}\r\n\r\nlet ToCommitDeletion = true;\r\n\r\nfunction commitDeletion(fiber: Fiber, toClearReactiveFunction?: boolean) {\r\n    if (!fiber || !ToCommitDeletion) return;\r\n    if (fiber.renderFunction) {\r\n        if (toClearReactiveFunction)\r\n            clearReactiveFunction(fiber.renderFunction);\r\n        delete fiber.renderFunction;\r\n    }\r\n    if (fiber.dom) {\r\n        for (const prop in fiber.props) {\r\n            if (isEvent(prop)) {\r\n                let eventName = prop.toLowerCase().substring(2);\r\n                const useCapture =\r\n                    eventName !=\r\n                    (eventName = eventName.replace(CAPTURE_REGEX, \"$1\"));\r\n\r\n                fiber.dom.removeEventListener(\r\n                    eventName,\r\n                    fiber.props[prop],\r\n                    useCapture\r\n                );\r\n                delete fiber.props[prop];\r\n            } else if (typeof fiber.props[prop] === \"function\") {\r\n                clearReactiveAttributes(fiber.props[prop]);\r\n            } else if (prop === \"ref\" && fiber.props[prop] instanceof Ref) {\r\n                fiber.props[prop].current = null;\r\n            }\r\n        }\r\n\r\n        fiber.dom.remove();\r\n    }\r\n    if (typeof fiber.type === \"function\") {\r\n        cleanUpFC(fiber, fiber.props);\r\n        // @ts-expect-error\r\n        delete fiber.type;\r\n    }\r\n    fiber.props.children.forEach((child) => commitDeletion(child, true));\r\n}\r\n\r\nfunction setRenderFunction(fiber: Fiber) {\r\n    if (!fiber.renderFunction) return;\r\n    setReactiveFunction(fiber.renderFunction, fiber);\r\n}\r\n\r\nexport function updateFiber(prevFiber: Fiber, newValue) {\r\n    // console.log(\"Prev value\", prevFiber, newValue);\r\n    // startTime = performance.now();\r\n    if (isPrimitive(newValue)) {\r\n        // console.log(fiber, newValue);\r\n        const newFragment: Fiber = {\r\n            ...createTextChildren(newValue),\r\n            parent: prevFiber.parent,\r\n        };\r\n        createFiber(newFragment);\r\n        // console.log(\"New Text Fiber\", newFragment);\r\n\r\n        updateNode(prevFiber, newFragment);\r\n    } else if (Array.isArray(newValue)) {\r\n        const isFragment = newValue[FRAGMENT_SYMBOL];\r\n\r\n        const newFragment: Fiber = {\r\n            type: \"FRAGMENT\",\r\n            props: {\r\n                children: isFragment ? newValue : createChildren(newValue),\r\n            },\r\n            parent: prevFiber.parent,\r\n        };\r\n\r\n        createFiber(newFragment);\r\n        updateNode(prevFiber, newFragment);\r\n    } else {\r\n        const newFragment = { ...newValue, parent: prevFiber.parent };\r\n        createFiber(newFragment);\r\n        // console.log(\"New Node Fiber\", newFragment);\r\n        updateNode(prevFiber, newFragment);\r\n    }\r\n    // const endTime = performance.now();\r\n    // console.log(\"Update Time:\", (endTime - startTime).toFixed(2), \"ms\");\r\n}\r\n\r\nfunction replaceRenderFunction(prev: Fiber, next: Fiber) {\r\n    if (prev.renderFunction) {\r\n        next.renderFunction = prev.renderFunction;\r\n        // console.log(\"Replace render function\", prev, next);\r\n        // deleteReactiveFunction(prev.renderFunction);\r\n        setRenderFunction(next);\r\n    }\r\n}\r\n\r\nfunction replaceChildFromParent(prev: Fiber, next: Fiber, index?: number) {\r\n    if (index !== undefined) {\r\n        prev.parent.props.children[index] = next;\r\n        return;\r\n    }\r\n    prev.parent?.props.children.forEach((child, i) => {\r\n        if (child === prev) {\r\n            prev.parent.props.children[i] = next;\r\n        }\r\n    });\r\n}\r\n\r\nexport const isEvent = (key: string) =>\r\n    key.startsWith(\"on\") || key == \"onFocusOut\" || key == \"onFocusIn\";\r\nexport const isProperty = (key: string) =>\r\n    key !== \"children\" && !isEvent(key) && key !== \"key\" && key !== \"ref\";\r\nconst isNew = (prev: any, next: any, key: string) => prev[key] !== next[key];\r\nconst isGone = (prev: any, next: any, key: string) => !(key in next);\r\n\r\nfunction deepCompareFibers(fiberA: any, fiberB: any): boolean {\r\n    // Fast path: identical references\r\n    if (fiberA === fiberB) {\r\n        return true;\r\n    }\r\n\r\n    // Compare the fiber types (e.g., function for FCs, string for DOM nodes)\r\n    if (fiberA.type !== fiberB.type) {\r\n        return false;\r\n    }\r\n\r\n    // Compare keys if they exist\r\n    if (fiberA.props?.key !== fiberB.props?.key) {\r\n        return false;\r\n    }\r\n    return deepEqual(fiberA.props, fiberB.props);\r\n}\r\n\r\nfunction deepEqual(objA: any, objB: any): boolean {\r\n    if (objA === objB) {\r\n        // console.log(\"Signal prop\");\r\n\r\n        if (objA instanceof BaseSignal && objB instanceof BaseSignal)\r\n            return deepEqual(objA.value, objB.value);\r\n        if (Array.isArray(objA) && Array.isArray(objB)) {\r\n            if (objA.length !== objB.length) return false;\r\n            for (let i = 0; i < objA.length; i++) {\r\n                if (!deepEqual(objA[i], objB[i])) return false;\r\n            }\r\n        }\r\n        return true;\r\n    } // Same reference or primitive value\r\n\r\n    if (isPrimitive(objA) && isPrimitive(objB)) {\r\n        return objA === objB; // One is not an object or is null\r\n    }\r\n\r\n    if (typeof objA !== typeof objB) return false;\r\n\r\n    const keysA = Object.keys(objA);\r\n    const keysB = Object.keys(objB);\r\n\r\n    if (keysA.length !== keysB.length) return false; // Different number of keys\r\n\r\n    for (let key of keysA) {\r\n        if (key === \"children\") continue;\r\n        if (!objB.hasOwnProperty(key)) return false; // Missing key in one of them\r\n        if (!deepEqual(objA[key], objB[key])) return false; // Recurse for nested objects/arrays\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction findFirstDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n    if (!fiber) return;\r\n\r\n    if (fiber.dom) return fiber.dom;\r\n\r\n    for (const child of fiber.props.children) {\r\n        const dom = findFirstDom(child);\r\n        if (dom) return dom;\r\n    }\r\n}\r\n// function findFirstChildDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n//     if (!fiber) return;\r\n\r\n//     for (const child of fiber.props.children) {\r\n//         const dom = findFirstDom(child);\r\n//         if (dom) return dom;\r\n//     }\r\n// }\r\nfunction findLastDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n    if (!fiber) return;\r\n\r\n    if (fiber.dom) return fiber.dom;\r\n\r\n    for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n        const child = fiber.props.children[i];\r\n        const dom = findLastDom(child);\r\n        if (dom) return dom;\r\n    }\r\n}\r\nfunction findLastChildDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n    if (!fiber) return;\r\n\r\n    for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n        const child = fiber.props.children[i];\r\n        const dom = findLastDom(child);\r\n        if (dom) return dom;\r\n    }\r\n}\r\nfunction findParentFiberWithDom(fiber: Fiber): Fiber | undefined {\r\n    if (!fiber) return;\r\n    let fiberParent = fiber.parent;\r\n    while (fiberParent && !fiberParent.dom) {\r\n        fiberParent = fiberParent.parent;\r\n    }\r\n    return fiberParent;\r\n}\r\nfunction findNearestParentWithDom(fiber: Fiber): Fiber | undefined {\r\n    if (!fiber) return;\r\n    if (fiber.dom) return fiber;\r\n\r\n    let fiberParent = fiber.parent;\r\n    while (fiberParent && !fiberParent.dom) {\r\n        fiberParent = fiberParent.parent;\r\n    }\r\n    return fiberParent;\r\n}\r\n\r\nfunction updateNode(\r\n    prev: Fiber | undefined,\r\n    next: Fiber | undefined,\r\n    index?: number\r\n) {\r\n    if (!prev && !next) return;\r\n\r\n    if (prev && !next) {\r\n        commitDeletion(prev, true);\r\n        // console.log(\"to remove\", prev);\r\n        prev.parent.props.children = prev.parent.props.children.filter(\r\n            (child) => child !== prev\r\n        );\r\n    } else if (prev && next) {\r\n        const prevProps = prev.props;\r\n        const nextProps = next.props;\r\n        if (prev.type === \"FRAGMENT\" || typeof prev.type === \"function\") {\r\n            // PREV IS FRAGMENT\r\n            if (next.type === \"FRAGMENT\" || typeof next.type === \"function\") {\r\n                // console.log(\"Fragment-Fragment\", prev, next);\r\n                if (\r\n                    typeof prev.type === typeof next.type &&\r\n                    typeof prev.type === \"function\"\r\n                ) {\r\n                    const areSame = deepCompareFibers(prev, next);\r\n                    if (!areSame) {\r\n                        commitFiber(next, findFirstDom(prev), undefined, true);\r\n\r\n                        replaceRenderFunction(prev, next);\r\n                        commitDeletion(prev);\r\n                        replaceChildFromParent(prev, next, index);\r\n                    }\r\n                } else {\r\n                    // console.log(\"fragment-fragment\", { ...prev }, next);\r\n\r\n                    updateChildren(prev, next);\r\n                }\r\n                // replaceChildFromParent(prev, next);\r\n            } else {\r\n                next.parent = prev.parent;\r\n                let firstChild: Fiber | undefined = prev.props.children[0];\r\n                while (firstChild && !firstChild.dom)\r\n                    firstChild = firstChild.props.children[0];\r\n                commitFiber(next, firstChild?.dom);\r\n\r\n                replaceRenderFunction(prev, next);\r\n                // removing all nodes of previous fragment\r\n                commitDeletion(prev);\r\n                replaceChildFromParent(prev, next, index);\r\n            }\r\n        } else {\r\n            // PREV IS NODE\r\n\r\n            const node = prev.dom;\r\n            if (\r\n                prev.type === \"TEXT_CHILD\" &&\r\n                next.type === \"TEXT_CHILD\" &&\r\n                !next.dom\r\n            )\r\n                next.dom = prev.dom;\r\n            if (node === undefined) {\r\n                // console.error(\"no node found\", prev, next);\r\n                return;\r\n            }\r\n            // console.log(prev);\r\n            if (next.type === \"FRAGMENT\" || typeof next.type === \"function\") {\r\n                // console.log(\"Node-Fragment\");\r\n                next.parent = prev.parent;\r\n                replaceRenderFunction(prev, next);\r\n\r\n                commitFiber(next, node);\r\n                commitDeletion(prev);\r\n                replaceChildFromParent(prev, next, index);\r\n            } else {\r\n                // console.log(\"Node-Node\");\r\n                // remove old properties and event listeners from NODE\r\n                for (const prop in prevProps) {\r\n                    if (\r\n                        isProperty(prop) &&\r\n                        isGone(prevProps, nextProps, prop)\r\n                    ) {\r\n                        node[prop] = \"\";\r\n                        // console.log(\"property removed\", prop);\r\n                    } else if (\r\n                        isEvent(prop) &&\r\n                        (!(prop in nextProps) ||\r\n                            isNew(prevProps, nextProps, prop))\r\n                    ) {\r\n                        let eventName = prop.toLowerCase().substring(2);\r\n                        const useCapture =\r\n                            eventName !=\r\n                            (eventName = eventName.replace(\r\n                                CAPTURE_REGEX,\r\n                                \"$1\"\r\n                            ));\r\n\r\n                        node.removeEventListener(\r\n                            eventName,\r\n                            prevProps[prop],\r\n                            useCapture\r\n                        );\r\n                        // console.log(\"event listener removed\", prop);\r\n                    }\r\n                }\r\n                if (prev.type !== next.type) {\r\n                    // console.log(\"Different type\", prev, next);\r\n                    next.parent = prev.parent;\r\n\r\n                    replaceRenderFunction(prev, next);\r\n\r\n                    commitFiber(next, node, true);\r\n                    commitDeletion(prev);\r\n                    replaceChildFromParent(prev, next, index);\r\n\r\n                    // console.log(prev.parent);\r\n                } else {\r\n                    // add new properties\r\n                    // console.log(\"same type\", prev, next);\r\n\r\n                    for (const prop in nextProps) {\r\n                        if (\r\n                            isProperty(prop) &&\r\n                            isNew(prevProps, nextProps, prop)\r\n                        ) {\r\n                            node[prop] = nextProps[prop];\r\n                            // console.log(\r\n                            //     \"property added\",\r\n                            //     prop,\r\n                            //     nextProps[prop]\r\n                            // );\r\n                            prevProps[prop] = nextProps[prop];\r\n                        } else if (\r\n                            isEvent(prop) &&\r\n                            isNew(prevProps, nextProps, prop)\r\n                        ) {\r\n                            let eventName = prop.toLowerCase().substring(2);\r\n                            const useCapture =\r\n                                eventName !=\r\n                                (eventName = eventName.replace(\r\n                                    CAPTURE_REGEX,\r\n                                    \"$1\"\r\n                                ));\r\n                            node.addEventListener(\r\n                                eventName,\r\n                                nextProps[prop],\r\n                                useCapture\r\n                            );\r\n                            prevProps[prop] = nextProps[prop];\r\n                        }\r\n                    }\r\n                    updateChildren(prev, next);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction reconcileList(prev: Fiber, next: Fiber) {\r\n    const oldFibers = prev.props.children;\r\n    const newFibers = next.props.children;\r\n\r\n    // Create a map from key to fiber for oldFibers.\r\n    const oldMap: Record<string, any> = {};\r\n    for (let i = 0; i < oldFibers.length; i++) {\r\n        const key = oldFibers[i].props.key;\r\n        if (\r\n            key === null ||\r\n            key === undefined ||\r\n            oldMap.hasOwnProperty(String(key))\r\n        ) {\r\n            // If any fiber is missing a key, we cannot reconcile.\r\n            // oldFibers[i].props.key =\r\n            return false;\r\n        }\r\n        oldMap[String(key)] = oldFibers[i];\r\n    }\r\n    const referenceNode = findLastChildDom(prev)?.nextSibling as\r\n        | Node\r\n        | undefined;\r\n    // Create newChildren array based on newFibers order.\r\n    const fiberParent = findParentFiberWithDom(prev);\r\n    // const fragment = document.createDocumentFragment();\r\n\r\n    if (newFibers.length === 0) {\r\n        prev.props.children.length = 0;\r\n        if (fiberParent?.dom instanceof HTMLElement)\r\n            fiberParent.dom.innerHTML = \"\";\r\n        return;\r\n    }\r\n    const prevLen = prev.props.children.length;\r\n\r\n    // const newChildren = new Array(newFibers.length);\r\n    for (let i = 0; i < newFibers.length; i++) {\r\n        const newFiber = newFibers[i];\r\n        const key = newFiber.props.key;\r\n        const keyStr = String(key);\r\n        // If the fiber exists in the old list, reuse it.\r\n        if (oldMap.hasOwnProperty(keyStr)) {\r\n            const oldFiber = oldMap[keyStr];\r\n\r\n            if (prevLen > i) prev.props.children[i] = oldFiber;\r\n            else prev.props.children.push(oldFiber);\r\n\r\n            delete oldMap[keyStr];\r\n\r\n            const newFiber = next.props.children[i];\r\n\r\n            if (newFiber) newFiber.parent = prev;\r\n\r\n            updateNode(oldFiber, newFiber, i);\r\n            applyFiber(\r\n                prev.props.children[i],\r\n                fiberParent?.dom!,\r\n                referenceNode\r\n            );\r\n        } else {\r\n            // Otherwise, use the new fiber.\r\n            // console.log(first)\r\n            if (prevLen > i) prev.props.children[i] = newFiber;\r\n            else prev.props.children.push(newFiber);\r\n\r\n            newFiber.parent = prev;\r\n            commitFiber(\r\n                newFiber,\r\n                referenceNode,\r\n                false,\r\n                false,\r\n                fiberParent?.dom\r\n            );\r\n        }\r\n    }\r\n    for (const key in oldMap) {\r\n        if (oldMap.hasOwnProperty(key)) {\r\n            const fiber = oldMap[key];\r\n            commitDeletion(fiber, true);\r\n        }\r\n    }\r\n    while (prev.props.children.length > next.props.children.length) {\r\n        prev.props.children.pop();\r\n    }\r\n\r\n    // fiberParent?.dom?.appendChild(fragment);\r\n}\r\n\r\nfunction applyFiber(fiber: Fiber, parent: Node, referenceNode?: Node) {\r\n    if (fiber.dom) {\r\n        if (fiber.dom === parent || fiber.dom === referenceNode) return;\r\n        if (referenceNode) {\r\n            parent.insertBefore(fiber.dom, referenceNode);\r\n        } else parent.appendChild(fiber.dom);\r\n    } else {\r\n        for (const child of fiber.props.children) {\r\n            applyFiber(child, parent, referenceNode);\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateChildren(prev: Fiber, next: Fiber) {\r\n    const isList =\r\n        next.type === \"FRAGMENT\" && !next.props.children[FRAGMENT_SYMBOL];\r\n\r\n    const wasList =\r\n        prev.type === \"FRAGMENT\" && !prev.props.children[FRAGMENT_SYMBOL];\r\n\r\n    // console.log(isList, wasList);\r\n\r\n    if (isList && wasList) {\r\n        const result = reconcileList(prev, next);\r\n        if (result === false) {\r\n            updateNonListChildrenWithKeys(prev, next);\r\n        }\r\n    } else {\r\n        updateNonListChildrenWithKeys(prev, next);\r\n    }\r\n    if (next.type === \"FRAGMENT\" && next.props.children[FRAGMENT_SYMBOL]) {\r\n        prev.props.children[FRAGMENT_SYMBOL] = true;\r\n    } else {\r\n        prev.props.children[FRAGMENT_SYMBOL] = false;\r\n    }\r\n\r\n    prev.type = next.type;\r\n}\r\n\r\nfunction updateNonListChildren(prev: Fiber, next: Fiber) {\r\n    let len = Math.max(prev.props.children.length, next.props.children.length);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let prevChild = prev.props.children[i];\r\n        let nextChild = next.props.children[i];\r\n\r\n        if (nextChild) nextChild.parent = prev;\r\n        if (!prevChild && nextChild) {\r\n            commitFiber(\r\n                nextChild,\r\n                // @ts-expect-error\r\n                findLastDom(prev.props.children.at(-1))?.nextSibling\r\n            );\r\n            prev.props.children.push(nextChild);\r\n        } else if (!nextChild && prevChild) {\r\n            commitDeletion(prevChild, true);\r\n            prev.props.children.splice(i, 1);\r\n            len = prev.props.children.length;\r\n            i--;\r\n        } else {\r\n            updateNode(prevChild, nextChild, i);\r\n            const newLen = Math.max(\r\n                prev.props.children.length,\r\n                next.props.children.length\r\n            );\r\n            if (newLen < len) {\r\n                len = newLen;\r\n                i--;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateNonListChildrenWithKeys(prev: Fiber, next: Fiber) {\r\n    let len = Math.max(prev.props.children.length, next.props.children.length);\r\n    const oldMap: Record<string, { fiber: Fiber; index: number }> = {};\r\n    let count = 0;\r\n    for (let i = 0; i < prev.props.children.length; i++) {\r\n        const key = prev.props.children[i].props.key;\r\n        if (key === null || key === undefined) {\r\n            continue;\r\n        }\r\n        count++;\r\n        if (oldMap.hasOwnProperty(String(key))) {\r\n            console.warn(\"Found two children with the same key\", key);\r\n            console.warn(\r\n                \"When two fibers are found having same key the whole children will default to manual updates, which can be slower than with key based reconciliation\"\r\n            );\r\n            updateNonListChildren(prev, next);\r\n            return;\r\n        }\r\n        oldMap[String(key)] = { fiber: prev.props.children[i], index: i };\r\n    }\r\n    if (count == 0) {\r\n        updateNonListChildren(prev, next);\r\n        return;\r\n    }\r\n    const newMap: Record<\r\n        string,\r\n        { fiber: Fiber; newIndex: number; oldIndex: number }\r\n    > = {};\r\n\r\n    for (let i = 0; i < next.props.children.length; i++) {\r\n        const key = next.props.children[i].props.key;\r\n        if (key === null || key === undefined) {\r\n            continue;\r\n        }\r\n        const oldFiber = oldMap[String(key)];\r\n        if (oldFiber) {\r\n            if (newMap.hasOwnProperty(String(key))) {\r\n                console.warn(\"Found two children with the same key\", key);\r\n                console.warn(\r\n                    \"When two fibers are found having same key the whole children will default to manual updates, which can be slower than with key based reconciliation\"\r\n                );\r\n                updateNonListChildren(prev, next);\r\n                return;\r\n            }\r\n            newMap[String(key)] = {\r\n                fiber: oldFiber.fiber,\r\n                newIndex: i,\r\n                oldIndex: oldFiber.index,\r\n            };\r\n        }\r\n    }\r\n    // console.log(prev, next);\r\n    const parent = findNearestParentWithDom(prev);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let prevChild = prev.props.children[i];\r\n        let nextChild = next.props.children[i];\r\n        // console.log(prevChild, nextChild);\r\n\r\n        const nextKey = nextChild?.props.key ? String(nextChild.props.key) : \"\";\r\n        const isReused = newMap.hasOwnProperty(nextKey);\r\n\r\n        let prevKey = prevChild?.props.key ? String(prevChild.props.key) : \"\";\r\n\r\n        if (prevKey && nextKey && prevKey === nextKey) {\r\n            // console.log(\"same\", prevChild, nextChild);\r\n            updateNode(prevChild, nextChild, i);\r\n\r\n            if (parent?.dom) applyFiber(prev.props.children[i], parent.dom);\r\n            continue;\r\n        }\r\n\r\n        const isUsedLater =\r\n            newMap.hasOwnProperty(prevKey) && newMap[prevKey].newIndex > i;\r\n        const isUsedPreviously =\r\n            newMap.hasOwnProperty(prevKey) && newMap[prevKey].newIndex < i;\r\n\r\n        if (isUsedLater || isUsedPreviously) {\r\n            ToCommitDeletion = false;\r\n        }\r\n\r\n        if (nextChild) nextChild.parent = prev;\r\n\r\n        if (!prevChild && nextChild) {\r\n            if (isReused) {\r\n                const { fiber } = newMap[nextKey];\r\n\r\n                prev.props.children.push(fiber);\r\n\r\n                updateNode(fiber, nextChild, i);\r\n\r\n                if (parent?.dom) applyFiber(prev.props.children[i], parent.dom);\r\n            } else {\r\n                // needCreation just creates parent child heirarchy\r\n                if (parent?.dom)\r\n                    commitFiber(nextChild, undefined, false, false, parent.dom);\r\n                prev.props.children.push(nextChild);\r\n            }\r\n        } else if (!nextChild && prevChild) {\r\n            commitDeletion(prevChild, true);\r\n            prev.props.children.splice(i, 1);\r\n            len = prev.props.children.length;\r\n            i--;\r\n        } else {\r\n            if (isReused) {\r\n                const { fiber } = newMap[nextKey];\r\n\r\n                commitDeletion(prevChild, true);\r\n                // because updateNode can call commitDeletion internally\r\n                ToCommitDeletion = true;\r\n\r\n                prev.props.children[i] = fiber;\r\n\r\n                updateNode(fiber, nextChild, i);\r\n\r\n                if (parent?.dom) applyFiber(prev.props.children[i], parent.dom);\r\n            } else {\r\n                // console.log(ToCommitDeletion);\r\n                if (isUsedLater || isUsedPreviously) {\r\n                    if (parent?.dom)\r\n                        commitFiber(\r\n                            nextChild,\r\n                            undefined,\r\n                            false,\r\n                            false,\r\n                            parent.dom\r\n                        );\r\n                    prev.props.children[i] = nextChild;\r\n                } else {\r\n                    updateNode(prevChild, nextChild, i);\r\n                    if (parent?.dom)\r\n                        applyFiber(prev.props.children[i], parent.dom);\r\n\r\n                    const newLen = Math.max(\r\n                        prev.props.children.length,\r\n                        next.props.children.length\r\n                    );\r\n                    if (newLen < len) {\r\n                        len = newLen;\r\n                        i--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ToCommitDeletion = true;\r\n    }\r\n    // console.log(prev.props.children, next.props.children);\r\n}\r\n\r\n// @ts-expect-error\r\nif (typeof process !== \"undefined\" && process.env.NODE_ENV === \"test\") {\r\n    // @ts-expect-error\r\n    module.exports = {\r\n        createFiber,\r\n        commitDeletion,\r\n        commitFiber,\r\n        updateFiber,\r\n        deepCompareFibers,\r\n        deepEqual,\r\n    };\r\n}\r\n","import { BaseSignal, runEffect } from \"../signals/signal\";\r\nimport { Fiber } from \"../types\";\r\n\r\nlet currentFC: Fiber | null = null;\r\nlet fcMap = new WeakMap<\r\n    Fiber,\r\n    {\r\n        signals: Set<BaseSignal<any>>;\r\n        cleanup: Function[];\r\n        effects: Set<Function>;\r\n    }\r\n>();\r\n\r\nexport function setCurrentFC(fc: Fiber) {\r\n    currentFC = fc;\r\n}\r\n\r\nexport function clearCurrentFC() {\r\n    currentFC = null;\r\n}\r\nexport function getCurrentFC() {\r\n    return currentFC;\r\n}\r\n\r\nexport function runAllEffects(FC: Fiber) {\r\n    if (fcMap.has(FC)) {\r\n        const fcData = fcMap.get(FC)!;\r\n\r\n        for (const effect of fcData.effects) {\r\n            runEffect(effect, FC);\r\n        }\r\n    }\r\n}\r\n\r\nexport function cleanUp(fn: Function) {\r\n    if (currentFC) {\r\n        // console.log(currentFC, fcMap.has(currentFC));\r\n        if (fcMap.has(currentFC)) {\r\n            const fcData = fcMap.get(currentFC)!;\r\n\r\n            fcData.cleanup.push(fn);\r\n        } else {\r\n            fcMap.set(currentFC, {\r\n                signals: new Set(),\r\n                cleanup: [fn],\r\n                effects: new Set(),\r\n            });\r\n        }\r\n    }\r\n}\r\nexport function cleanUpWFiber(fn: Function, fiber: Fiber) {\r\n    if (fiber) {\r\n        // console.log(currentFC, fcMap.has(currentFC));\r\n        if (fcMap.has(fiber)) {\r\n            const fcData = fcMap.get(fiber)!;\r\n\r\n            fcData.cleanup.push(fn);\r\n        } else {\r\n            fcMap.set(fiber, {\r\n                signals: new Set(),\r\n                cleanup: [fn],\r\n                effects: new Set(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport function addEffect(fn: Function) {\r\n    if (currentFC) {\r\n        if (fcMap.has(currentFC)) {\r\n            const fcData = fcMap.get(currentFC)!;\r\n            fcData.effects.add(fn);\r\n        } else {\r\n            const effects = new Set<Function>();\r\n            effects.add(fn);\r\n            fcMap.set(currentFC, {\r\n                signals: new Set(),\r\n                cleanup: [],\r\n                effects: effects,\r\n            });\r\n        }\r\n    }\r\n}\r\nexport function addSignal(signal: BaseSignal<any>) {\r\n    if (currentFC) {\r\n        if (fcMap.has(currentFC)) {\r\n            const fcData = fcMap.get(currentFC)!;\r\n            fcData.signals.add(signal);\r\n        } else {\r\n            const signals = new Set<BaseSignal<any>>();\r\n            signals.add(signal);\r\n            fcMap.set(currentFC, {\r\n                signals: signals,\r\n                cleanup: [],\r\n                effects: new Set(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport function cleanUpFC(currentFC, props) {\r\n    const fcData = fcMap.get(currentFC)!;\r\n    if (fcData) {\r\n        // console.log(\"Cleaning up FC\", currentFC, fcData);\r\n        if (fcData.cleanup) {\r\n            for (const fn of fcData.cleanup) {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        fcData.cleanup = [];\r\n\r\n        for (const effect of fcData.effects) {\r\n            // @ts-expect-error\r\n            if (effect.__cleanup && typeof effect.__cleanup === \"function\") {\r\n                // @ts-expect-error\r\n                effect.__cleanup();\r\n            }\r\n            // @ts-expect-error\r\n            if (effect.__signals) {\r\n                // @ts-expect-error\r\n                for (const signal of effect.__signals) {\r\n                    signal.removeDep(effect);\r\n                }\r\n            }\r\n            // @ts-expect-error\r\n            delete effect.__signals;\r\n            // @ts-expect-error\r\n            delete effect.__cleanup;\r\n        }\r\n\r\n        fcData.signals.forEach((signal) => signal.clearDeps());\r\n        fcData.signals.clear();\r\n    }\r\n    fcMap.delete(currentFC);\r\n}\r\n","import { ComponentChildren, createSignal, Fiber, PublicSignal } from \"../index\";\r\n\r\ndeclare const FRAGMENT = \"FRAGMENT\";\r\n\r\n// If the component takes no parameters, treat its props as {}\r\ntype PropsOf<T extends (...args: any) => any> = Parameters<T> extends []\r\n    ? {}\r\n    : Parameters<T>[0];\r\n\r\nexport function lazy<T extends (props: any) => any>(\r\n    importFn: () => Promise<{ default: T }>\r\n): (\r\n    props: PropsOf<T> & {\r\n        fallback?: ComponentChildren;\r\n        errorFallback?:\r\n            | ComponentChildren\r\n            | ((error: Error) => ComponentChildren);\r\n    }\r\n) => ReturnType<T> {\r\n    let Component: T | null = null;\r\n\r\n    const load = (\r\n        loading: PublicSignal<boolean>,\r\n        error: PublicSignal<Error | null>\r\n    ) => {\r\n        if (!Component) {\r\n            importFn()\r\n                .then((mod) => {\r\n                    if (mod.default) {\r\n                        if (typeof mod.default !== \"function\") {\r\n                            throw new Error(\r\n                                \"Lazy-loaded component must be a functional component\"\r\n                            );\r\n                        }\r\n                        Component = mod.default;\r\n\r\n                        loading.update(false);\r\n                        error.update(null);\r\n                    } else {\r\n                        error.update(\r\n                            new Error(\r\n                                \"No default export found from lazy-loaded module\"\r\n                            )\r\n                        );\r\n                    }\r\n                })\r\n                .catch((err) => {\r\n                    error.update(err);\r\n                    loading.update(false);\r\n                });\r\n        } else {\r\n            loading.update(false);\r\n            error.update(null);\r\n        }\r\n    };\r\n\r\n    return (\r\n        props: PropsOf<T> & {\r\n            fallback?: Node;\r\n            errorFallback?: Node;\r\n        }\r\n    ): ReturnType<T> => {\r\n        const loading = createSignal<boolean>(true);\r\n        const error = createSignal<Error | null>(null);\r\n\r\n        load(loading, error);\r\n        // Validate fallback and errorFallback types\r\n        const isValidNode = (val: any) =>\r\n            typeof val === \"string\" ||\r\n            (val && typeof val === \"object\" && \"props\" in val && \"type\" in val);\r\n\r\n        if (props.fallback !== undefined && !isValidNode(props.fallback)) {\r\n            throw new Error(\r\n                \"Invalid fallback: Expected a string or a valid JSX node.\"\r\n            );\r\n        }\r\n        if (\r\n            props.errorFallback !== undefined &&\r\n            !(\r\n                typeof props.errorFallback === \"function\" ||\r\n                isValidNode(props.errorFallback)\r\n            )\r\n        ) {\r\n            throw new Error(\r\n                \"Invalid errorFallback: Expected a string, a valid JSX node, or a function returning a JSX node.\"\r\n            );\r\n        }\r\n\r\n        return (\r\n            <>\r\n                {() =>\r\n                    loading.value\r\n                        ? props.fallback\r\n                        : error.value !== null\r\n                        ? props.errorFallback\r\n                            ? typeof props.errorFallback === \"function\"\r\n                                ? props.errorFallback(error.value)\r\n                                : props.errorFallback\r\n                            : \"Unknown error occurred while lazy loading component, use errorFallback prop to override\"\r\n                        : // @ts-expect-error\r\n                          Component && <Component {...props} />\r\n                }\r\n            </>\r\n        ) as unknown as ReturnType<T>;\r\n    };\r\n}\r\n"],"names":["isPlainObject","variable","Array","isArray","Object","prototype","toString","call","isPrimitive","val","includes","Error","SVG_NAMESPACE","SVG_TAGS","Set","MATH_TAGS","CAPTURE_REGEX","IS_NON_DIMENSIONAL","setReactiveAttribute","reactiveFunction","name","dom","namespace","__propName","fn","currentReactiveFunction","retVal","reactiveAttribute","setAttribute","__signals","domAttributeMap","set","setReactiveAttributes","value","useCapture","replace","toLowerCase","slice","addEventListener","tagName","setTimeout","e","style","isValidStyle","processedStyle","key","preprocessStyle","newStyles","cssKey","test","push","join","styleObjectToString","setStyle","FRAGMENT_SYMBOL","Symbol","createElement","type","props","children","fragments","createChildren","map","child","createTextChildren","_a","reactive","createSignalChild","nodeValue","String","flat","text","renderFunction","createNode","element","has","document","createTextNode","createElementNS","is","ref","Ref","HTMLElement","current","elements","rootContainer","rootFragment","effectQueue","processEffectQueue","i","length","runAllEffects","workLoop","deadline","shouldYield","renderNode","pop","timeRemaining","appendChild","requestIdleCallback","fiber","noKey","parent","setCurrentFC","clearCurrentFC","fiberParent","setRenderFunction","createFiber","commitFiber","referenceNode","needCreation","customParent","queueMicrotask","parentElement","replaceChild","_b","insertBefore","parentDom","ToCommitDeletion","commitDeletion","toClearReactiveFunction","reactiveFiberMap","delete","signals","signal","removeDep","clearReactiveFunction","prop","isEvent","eventName","substring","removeEventListener","clearReactiveAttributes","remove","currentFC","fcData","fcMap","get","cleanup","effect","effects","__cleanup","forEach","clearDeps","clear","cleanUpFC","setReactiveFunction","updateFiber","prevFiber","newValue","newFragment","updateNode","replaceRenderFunction","prev","next","replaceChildFromParent","index","startsWith","isProperty","isNew","isGone","deepCompareFibers","fiberA","fiberB","deepEqual","objA","objB","BaseSignal","keysA","keys","keysB","hasOwnProperty","findFirstDom","findLastDom","filter","prevProps","nextProps","updateChildren","firstChild","node","applyFiber","isList","wasList","oldFibers","newFibers","oldMap","findLastChildDom","nextSibling","findParentFiberWithDom","innerHTML","prevLen","newFiber","keyStr","oldFiber","reconcileList","updateNonListChildrenWithKeys","updateNonListChildren","len","Math","max","prevChild","nextChild","at","splice","newLen","count","newMap","newIndex","oldIndex","findNearestParentWithDom","nextKey","isReused","prevKey","isUsedLater","isUsedPreviously","process","env","NODE_ENV","module","exports","scheduled","batch","depset","WeakMap","currentEffect","addSignalToReactiveFunction","add","addSignalToEffect","runEffect","effectCleanup","cleanUpWFiber","cleanUp","constructor","this","MutatingMethods","isNotified","_val","deps","notify","size","dep","cb","updateDomProp","PrimitiveSignal","super","update","newVal","ArraySignal","updateCalled","createProxy","Proxy","target","args","result","apply","ObjectSignal","createInternalArrayProxy","deleteProperty","createSignal","addSignal","bind","fc","getCurrentFC","FC","addEffect","firstRun","promise","Promise","triggerSignal","status","data","error","then","catch","err","importFn","Component","loading","mod","default","load","isValidNode","fallback","errorFallback","container","fragment","createDocumentFragment","rootFiber"],"mappings":"aAAO,SAASA,EAAcC,GAC1B,MACwB,iBAAbA,GACM,OAAbA,IACCC,MAAMC,QAAQF,IAC8B,oBAA7CG,OAAOC,UAAUC,SAASC,KAAKN,EAEvC,CACO,SAASO,EAAYC,GACxB,MACI,CAAC,UAAW,SAAU,SAAU,aAAaC,gBAAgBD,IACrD,OAARA,GACAA,aAAeE,KAEvB,oECdO,MAAMC,EAAgB,6BAChBC,MAAeC,IAAI,CAC5B,MACA,IACA,SACA,WACA,OACA,OACA,UACA,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACA,SACA,gBACA,IACA,QACA,OACA,iBACA,SACA,OACA,WACA,OACA,UACA,UACA,WACA,iBACA,OACA,SACA,MACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,QACA,MACA,SAESC,MAAgBD,IAAI,CAC7B,OACA,UACA,cACA,aACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,WACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,YACA,UACA,UACA,SACA,SACA,QACA,QACA,SACA,SACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,eAKSE,EAAgB,8BCzGhBC,EACT,oECoBG,SAASC,EACZC,EACAC,EACAC,EACAC,GAEAH,EAAiBI,WAAaH,EAExB,MAAAX,ECeH,SAA2Be,GAC9B,GAAkB,mBAAPA,EACD,MAAA,IAAIb,MAAM,oDAEMc,EAAAD,EAC1B,MAAME,EAASF,IAGR,OAFmBC,EAAA,KAEnBC,CACX,CDxBgBC,CAAkBR,GAC1BV,UAA6C,IAARA,IAI5BmB,EAAAR,EAAMX,EAAKY,EAAKC,GAEzBH,EAAiBU,WEwBT,SAAsBL,EAAcH,GAEhCS,EAAAC,IAAIP,EAAIH,EAC5B,CF1BQW,CAAsBb,EAAkBE,GAChD,CAEA,MAAML,EAAgB,8BAEf,SAASY,EACZR,EACAa,EACAZ,EACAC,GAEA,GAAY,SAARF,EAAJ,CAI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"}