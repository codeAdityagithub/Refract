{"version":3,"file":"refract.es.js","sources":["../src/utils/general.ts","../src/rendering/constants.ts","../src/lib.ts","../src/rendering/props.ts","../src/rendering/createElements.ts","../src/rendering/render.ts","../src/signals/batch.ts","../src/signals/signal.ts","../src/rendering/functionalComponents.ts","../src/lazy/Lazyloading.tsx"],"sourcesContent":["export function isPlainObject(variable: any) {\r\n    return (\r\n        typeof variable === \"object\" && // Must be an object\r\n        variable !== null && // Cannot be null\r\n        !Array.isArray(variable) && // Cannot be an array\r\n        Object.prototype.toString.call(variable) === \"[object Object]\" // Must be a plain object\r\n    );\r\n}\r\nexport function isPrimitive(val: any) {\r\n    return (\r\n        [\"boolean\", \"string\", \"number\", \"undefined\"].includes(typeof val) ||\r\n        val === null ||\r\n        val instanceof Error\r\n    );\r\n}\r\n\r\nexport function swap(arr: any[], i: number, j: number) {\r\n    const temp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = temp;\r\n}\r\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\r\nexport const SVG_TAGS = new Set([\r\n    \"svg\",\r\n    \"a\",\r\n    \"circle\",\r\n    \"clipPath\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"feBlend\",\r\n    \"feColorMatrix\",\r\n    \"feComponentTransfer\",\r\n    \"feComposite\",\r\n    \"feConvolveMatrix\",\r\n    \"feDiffuseLighting\",\r\n    \"feDisplacementMap\",\r\n    \"feDistantLight\",\r\n    \"feDropShadow\",\r\n    \"feFlood\",\r\n    \"feFuncA\",\r\n    \"feFuncB\",\r\n    \"feFuncG\",\r\n    \"feFuncR\",\r\n    \"feGaussianBlur\",\r\n    \"feImage\",\r\n    \"feMerge\",\r\n    \"feMergeNode\",\r\n    \"feMorphology\",\r\n    \"feOffset\",\r\n    \"fePointLight\",\r\n    \"feSpecularLighting\",\r\n    \"feSpotLight\",\r\n    \"feTile\",\r\n    \"feTurbulence\",\r\n    \"filter\",\r\n    \"foreignObject\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"linearGradient\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"radialGradient\",\r\n    \"rect\",\r\n    \"script\",\r\n    \"set\",\r\n    \"stop\",\r\n    \"style\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"text\",\r\n    \"textPath\",\r\n    \"title\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n]);\r\nexport const MATH_TAGS = new Set([\r\n    \"math\",\r\n    \"maction\",\r\n    \"maligngroup\",\r\n    \"malignmark\",\r\n    \"menclose\",\r\n    \"merror\",\r\n    \"mfenced\",\r\n    \"mfrac\",\r\n    \"mglyph\",\r\n    \"mi\",\r\n    \"mlabeledtr\",\r\n    \"mlongdiv\",\r\n    \"mmultiscripts\",\r\n    \"mn\",\r\n    \"mo\",\r\n    \"mover\",\r\n    \"mpadded\",\r\n    \"mphantom\",\r\n    \"mroot\",\r\n    \"mrow\",\r\n    \"ms\",\r\n    \"mscarries\",\r\n    \"mscarry\",\r\n    \"msgroup\",\r\n    \"msline\",\r\n    \"mspace\",\r\n    \"msqrt\",\r\n    \"msrow\",\r\n    \"mstack\",\r\n    \"mstyle\",\r\n    \"msub\",\r\n    \"msup\",\r\n    \"msubsup\",\r\n    \"mtable\",\r\n    \"mtd\",\r\n    \"mtext\",\r\n    \"mtr\",\r\n    \"munder\",\r\n    \"munderover\",\r\n]);\r\n\r\nexport const MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\r\n\r\nexport const CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\r\n","import { isPlainObject } from \"./utils/general\";\r\nexport const IS_NON_DIMENSIONAL =\r\n    /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\r\n\r\nexport function styleObjectToString(\r\n    style: Record<string, string | number>\r\n): string {\r\n    const newStyles: string[] = [];\r\n\r\n    for (const key in style) {\r\n        const value = style[key];\r\n        const cssKey = key.replace(/([A-Z])/g, \"-$1\").toLowerCase(); // CamelCase to kebab-case\r\n\r\n        if (typeof value != \"number\" || IS_NON_DIMENSIONAL.test(cssKey)) {\r\n            newStyles.push(`${cssKey}: ${value};`); // Convert numbers to strings with px suffix\r\n        } else {\r\n            newStyles.push(`${cssKey}: ${value}px;`); // Convert numbers to strings with px suffix\r\n        }\r\n    }\r\n    return newStyles.join(\" \");\r\n}\r\n\r\nexport function preprocessStyle(\r\n    style: Record<string, any>\r\n): Record<string, string | number> {\r\n    const processedStyle: Record<string, string | number> = {};\r\n\r\n    for (const key in style) {\r\n        const value = style[key];\r\n        // Handle nested styles\r\n        if (typeof value === \"object\" && value !== null) {\r\n            console.warn(`Nested styles not allowed for ${key}`);\r\n            continue; // Skip nested styles\r\n        }\r\n\r\n        // Remove falsy values\r\n        if (\r\n            value === null ||\r\n            value === undefined ||\r\n            value === false ||\r\n            value === \"\"\r\n        ) {\r\n            continue;\r\n        }\r\n\r\n        // Otherwise, add to processed style\r\n        processedStyle[key] = value;\r\n    }\r\n\r\n    return processedStyle;\r\n}\r\n\r\nexport function isValidStyle(style: any) {\r\n    return isPlainObject(style) || typeof style === \"string\";\r\n}\r\n\r\nexport function applyMoves<T>(\r\n    arr: T[],\r\n    moves: Record<string, { from: number; to: number }>\r\n): T[] {\r\n    const n = arr.length;\r\n    // Create an array for the final result (we use undefined as a marker)\r\n    const result: (T | undefined)[] = new Array(n).fill(undefined);\r\n    // Keep track of which indices in the original array are moved.\r\n    const movedFrom = new Set<number>();\r\n\r\n    // First, place all moved elements at their target positions.\r\n    // (For a swap both targets will be filled by the respective moves.)\r\n    for (const key in moves) {\r\n        const { from, to } = moves[key];\r\n        // You can optionally ignore moves that are no-ops (from === to)\r\n        if (from === to) continue;\r\n        result[to] = arr[from];\r\n        movedFrom.add(from);\r\n    }\r\n\r\n    // Next, fill in the \"gaps\" with the unmoved elements,\r\n    // preserving their original order.\r\n    let fillIndex = 0; // current position in `result` to fill\r\n    for (let i = 0; i < n; i++) {\r\n        // Skip any element that was moved.\r\n        if (movedFrom.has(i)) continue;\r\n\r\n        // Advance fillIndex until we find an empty slot in result.\r\n        while (fillIndex < n && result[fillIndex] !== undefined) {\r\n            fillIndex++;\r\n        }\r\n        if (fillIndex < n) {\r\n            result[fillIndex] = arr[i];\r\n            fillIndex++;\r\n        }\r\n    }\r\n\r\n    return result as T[];\r\n}\r\n\r\n/**\r\n * Computes the indices of the longest increasing subsequence in the given array.\r\n * @param arr - An array of numbers.\r\n * @returns An array of indices representing the longest increasing subsequence.\r\n *\r\n * Time Complexity: O(n log n)\r\n */\r\nexport function longestIncreasingSubsequenceIndices(arr: number[]): number[] {\r\n    const n = arr.length;\r\n    const predecessors = new Array(n).fill(-1); // Track the previous index for each element in the subsequence.\r\n    const lisIndices: number[] = []; // Stores indices of the smallest tail for all increasing subsequences of each length.\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        const x = arr[i];\r\n\r\n        // Binary search for the insertion point in lisIndices.\r\n        let low = 0;\r\n        let high = lisIndices.length;\r\n        while (low < high) {\r\n            const mid = Math.floor((low + high) / 2);\r\n            if (arr[lisIndices[mid]] < x) {\r\n                low = mid + 1;\r\n            } else {\r\n                high = mid;\r\n            }\r\n        }\r\n\r\n        // If low is at the end, extend lisIndices; otherwise, update the tail value.\r\n        if (low === lisIndices.length) {\r\n            lisIndices.push(i);\r\n        } else {\r\n            lisIndices[low] = i;\r\n        }\r\n\r\n        // Set the predecessor of arr[i] (if low is not the start of a subsequence).\r\n        predecessors[i] = low > 0 ? lisIndices[low - 1] : -1;\r\n    }\r\n\r\n    // Reconstruct the longest increasing subsequence using the predecessors.\r\n    const lis: number[] = [];\r\n    let k = lisIndices.length > 0 ? lisIndices[lisIndices.length - 1] : -1;\r\n    for (let i = lisIndices.length - 1; i >= 0; i--) {\r\n        lis[i] = k;\r\n        k = predecessors[k];\r\n    }\r\n    return lis;\r\n}\r\n","import { isValidStyle, preprocessStyle, styleObjectToString } from \"../lib\";\r\nimport { setReactiveAttributes } from \"../signals/batch\";\r\nimport { reactiveAttribute } from \"../signals/signal\";\r\nimport { SVG_NAMESPACE } from \"./constants\";\r\n\r\nexport function setStyle(\r\n    style: Record<string, string | number> | string,\r\n    dom: HTMLElement\r\n) {\r\n    if (!isValidStyle(style))\r\n        throw new Error(\"Style attribute must be a plain object or a string\");\r\n\r\n    if (typeof style === \"string\") {\r\n        dom.setAttribute(\"style\", style);\r\n    } else {\r\n        const processedStyle = preprocessStyle(style);\r\n\r\n        dom.setAttribute(\"style\", styleObjectToString(processedStyle));\r\n    }\r\n}\r\n\r\n// handles setting the reactive attributes returned from a reactiveFunction\r\nexport function setReactiveAttribute(\r\n    reactiveFunction: any,\r\n    name: string,\r\n    dom: HTMLElement,\r\n    namespace?: string\r\n) {\r\n    reactiveFunction.__propName = name;\r\n    // registers the function in corresponding signal\r\n    const val = reactiveAttribute(reactiveFunction);\r\n    if (val === null || val === undefined || val === false) {\r\n        return;\r\n    }\r\n\r\n    setAttribute(name, val, dom, namespace);\r\n    // track this using signals if the function depended on any signal\r\n    if (reactiveFunction.__signals)\r\n        setReactiveAttributes(reactiveFunction, dom);\r\n}\r\n\r\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\r\n\r\nexport function setAttribute(\r\n    name: string,\r\n    value: any,\r\n    dom: HTMLElement,\r\n    namespace?: string\r\n) {\r\n    if (name == \"style\") {\r\n        setStyle(value, dom);\r\n        return;\r\n    }\r\n    if (name[0] === \"o\" && name[1] === \"n\" && typeof value === \"function\") {\r\n        const useCapture = name != (name = name.replace(CAPTURE_REGEX, \"$1\"));\r\n\r\n        if (\r\n            name.toLowerCase() in dom ||\r\n            name == \"onFocusOut\" ||\r\n            name == \"onFocusIn\" ||\r\n            name === \"onGotPointerCapture\" ||\r\n            name === \"onLostPointerCapture\"\r\n        )\r\n            name = name.toLowerCase().slice(2);\r\n        else name = name.slice(2);\r\n        // handle eventListeners\r\n        dom.addEventListener(name, value, useCapture);\r\n        return;\r\n    }\r\n\r\n    if (namespace === SVG_NAMESPACE) {\r\n        name = name.replace(/xlink(H|:h)/, \"h\").replace(/sName$/, \"s\");\r\n    }\r\n    // For certain properties that exist on the dom element,\r\n    // attempt to set them directly.\r\n    else if (\r\n        name !== \"width\" &&\r\n        name !== \"height\" &&\r\n        name !== \"href\" &&\r\n        name !== \"list\" &&\r\n        name !== \"form\" &&\r\n        name !== \"tabIndex\" &&\r\n        name !== \"download\" &&\r\n        name !== \"rowSpan\" &&\r\n        name !== \"colSpan\" &&\r\n        name !== \"role\" &&\r\n        name !== \"popover\" &&\r\n        name in dom\r\n    ) {\r\n        try {\r\n            // Set the property directly on the DOM element.\r\n            if (name === \"value\" && dom.tagName === \"SELECT\") {\r\n                setTimeout(() => {\r\n                    dom[name] = value == null ? \"\" : value;\r\n                });\r\n            } else {\r\n                dom[name] = value == null ? \"\" : value;\r\n            }\r\n            // console.log(dom[name], dom);\r\n\r\n            // We simply return after setting the property.\r\n            return;\r\n        } catch (e) {\r\n            // If setting the property fails, fall through to update attributes.\r\n        }\r\n    }\r\n\r\n    if (value != null && (value !== false || name[4] === \"-\")) {\r\n        // For most attributes, if the value is valid, set the attribute.\r\n        // Special case: for \"popover\", if value is true, set attribute to an empty string.\r\n\r\n        dom.setAttribute(\r\n            name,\r\n            name === \"popover\" && value === true ? \"\" : value\r\n        );\r\n    }\r\n}\r\n","import { isValidStyle, preprocessStyle, styleObjectToString } from \"../lib\";\r\nimport { setReactiveAttributes } from \"../signals/batch\";\r\nimport { reactive, reactiveAttribute, Ref } from \"../signals/signal\";\r\nimport {\r\n    Fiber,\r\n    FiberChildren,\r\n    NodeType,\r\n    Props,\r\n    RenderFunction,\r\n} from \"../types\";\r\nimport { isPrimitive } from \"../utils/general\";\r\nimport {\r\n    MATH_NAMESPACE,\r\n    MATH_TAGS,\r\n    SVG_NAMESPACE,\r\n    SVG_TAGS,\r\n} from \"./constants\";\r\nimport { setAttribute, setReactiveAttribute } from \"./props\";\r\nexport const FRAGMENT_SYMBOL = Symbol(\"FRAGMENT\");\r\n\r\nexport function createElement(\r\n    type: any,\r\n    props: object | null,\r\n    ...children: any[]\r\n): Fiber | FiberChildren {\r\n    if (type === \"FRAGMENT\") {\r\n        const fragments = createChildren(children);\r\n        fragments[FRAGMENT_SYMBOL] = true;\r\n\r\n        return fragments;\r\n    }\r\n    // @ts-expect-error\r\n    return {\r\n        type,\r\n        props: {\r\n            ...props,\r\n            children: createChildren(children),\r\n        },\r\n    };\r\n}\r\n\r\nexport function createChildren(children: FiberChildren): FiberChildren {\r\n    // @ts-expect-error\r\n    return children\r\n        .map((child) => {\r\n            if (typeof child === \"object\") {\r\n                if (Array.isArray(child)) {\r\n                    return createChildren(child);\r\n                }\r\n                if (child === null) {\r\n                    return createTextChildren(\"\");\r\n                }\r\n                if (!child.type || !child.props) {\r\n                    throw new Error(\r\n                        \"Invalid type for a dom node, found \" + child\r\n                    );\r\n                }\r\n                return child;\r\n            } else if (typeof child === \"function\") {\r\n                const val = reactive(child);\r\n                if (isPrimitive(val)) {\r\n                    return createSignalChild(\r\n                        \"TEXT_CHILD\",\r\n                        {\r\n                            nodeValue:\r\n                                val !== undefined &&\r\n                                val !== null &&\r\n                                val !== false\r\n                                    ? String(val)\r\n                                    : \"\",\r\n                            children: [],\r\n                        },\r\n                        child\r\n                    );\r\n                } else if (Array.isArray(val)) {\r\n                    // console.log(createChildren(val));\r\n                    const isFragment = val[FRAGMENT_SYMBOL];\r\n                    return createSignalChild(\r\n                        \"FRAGMENT\",\r\n                        { children: isFragment ? val : createChildren(val) },\r\n                        child\r\n                    );\r\n                } else if (!val.type || !val.props) {\r\n                    throw new Error(\r\n                        \"Invalid type for a dom node, found \" + val\r\n                    );\r\n                }\r\n                return createSignalChild(val.type, val.props, child);\r\n            } else {\r\n                return createTextChildren(child);\r\n            }\r\n        })\r\n        .flat();\r\n}\r\n\r\nexport function createTextChildren(text: any): Fiber {\r\n    // @ts-expect-error\r\n    return {\r\n        type: \"TEXT_CHILD\",\r\n        props: {\r\n            nodeValue:\r\n                text !== null && text !== undefined && text !== false\r\n                    ? String(text)\r\n                    : \"\",\r\n            children: [],\r\n        },\r\n    };\r\n}\r\n\r\nfunction createSignalChild(\r\n    type: NodeType,\r\n    props: Props,\r\n    renderFunction: RenderFunction\r\n) {\r\n    return {\r\n        type,\r\n        renderFunction,\r\n        props,\r\n    };\r\n}\r\n\r\nfunction isProperty(key: string) {\r\n    return key !== \"children\" && key !== \"key\" && key !== \"ref\";\r\n}\r\n\r\nexport function createNode(element: Fiber): HTMLElement | Text {\r\n    let namespace: string | null = null;\r\n\r\n    if (SVG_TAGS.has(element.type as string)) namespace = SVG_NAMESPACE;\r\n    else if (MATH_TAGS.has(element.type as string)) namespace = MATH_NAMESPACE;\r\n\r\n    const dom =\r\n        element.type === \"TEXT_CHILD\"\r\n            ? document.createTextNode(\"\")\r\n            : namespace\r\n            ? document.createElementNS(\r\n                  namespace,\r\n                  // @ts-expect-error\r\n                  element.type,\r\n                  element.props.is && element.props\r\n              )\r\n            : // @ts-expect-error\r\n              document.createElement(element.type);\r\n\r\n    if (!element.props) return dom as HTMLElement | Text;\r\n\r\n    if (\r\n        element.props.ref &&\r\n        element.props.ref instanceof Ref &&\r\n        dom instanceof HTMLElement\r\n    ) {\r\n        element.props.ref.current = dom;\r\n    }\r\n\r\n    for (const name in element.props) {\r\n        if (!isProperty(name)) {\r\n            continue;\r\n        }\r\n        const value = element.props[name];\r\n        if (typeof value === \"function\" && name[0] !== \"o\" && name[1] !== \"n\") {\r\n            // @ts-expect-error\r\n            setReactiveAttribute(value, name, dom, namespace);\r\n        } else {\r\n            // @ts-expect-error\r\n            setAttribute(name, value, dom, namespace);\r\n        }\r\n    }\r\n\r\n    return dom as HTMLElement | Text;\r\n}\r\n\r\nexport function updateDomProp(\r\n    prop: string,\r\n    dom: HTMLElement | Text,\r\n    value: any\r\n) {\r\n    if (value == null || prop === \"key\") return;\r\n\r\n    // @ts-expect-error\r\n    setAttribute(prop, value, dom);\r\n}\r\n\r\nexport const FRAGMENT = \"FRAGMENT\";\r\n","import {\r\n    clearReactiveAttributes,\r\n    clearReactiveFunction,\r\n    setReactiveFunction,\r\n} from \"../signals/batch\";\r\nimport { BaseSignal, Ref } from \"../signals/signal\";\r\nimport { Fiber, FiberChildren } from \"../types\";\r\nimport { isPrimitive } from \"../utils/general\";\r\nimport { CAPTURE_REGEX } from \"./constants\";\r\nimport {\r\n    FRAGMENT_SYMBOL,\r\n    createChildren,\r\n    createNode,\r\n    createTextChildren,\r\n} from \"./createElements\";\r\nimport {\r\n    cleanUpFC,\r\n    clearCurrentFC,\r\n    runAllEffects,\r\n    setCurrentFC,\r\n} from \"./functionalComponents\";\r\n\r\nexport function render(element: Fiber, container: HTMLElement) {\r\n    rootContainer = container;\r\n    const fragment = document.createDocumentFragment();\r\n    rootFragment = fragment;\r\n    const rootFiber: Fiber = {\r\n        type: \"div\",\r\n        props: {\r\n            children: [element],\r\n        },\r\n        // @ts-expect-error\r\n        dom: fragment,\r\n    };\r\n    // console.log(element.type(element.props));\r\n    element.parent = rootFiber;\r\n    elements.push(element);\r\n    requestIdleCallback(workLoop);\r\n\r\n    // container.appendChild(fragment);\r\n}\r\n\r\nfunction commitRootFragment() {\r\n    if (rootFragment && rootContainer) {\r\n        rootContainer.appendChild(rootFragment);\r\n        // const endTime = performance.now();\r\n        // console.log(`Render time: ${endTime - startTime}ms`);\r\n    }\r\n}\r\n\r\nlet elements: Fiber[] = [];\r\nlet rootContainer: HTMLElement | null = null;\r\nlet rootFragment: DocumentFragment | null = null;\r\n// let startTime = -1;\r\nlet effectQueue: Fiber[] = [];\r\n\r\nfunction processEffectQueue() {\r\n    for (let i = 0; i < effectQueue.length; i++) {\r\n        const fiber = effectQueue[i];\r\n        runAllEffects(fiber);\r\n    }\r\n    effectQueue.length = 0;\r\n}\r\n\r\nfunction workLoop(deadline: IdleDeadline) {\r\n    // if (startTime === -1) startTime = performance.now();\r\n\r\n    processEffectQueue();\r\n    let shouldYield = false;\r\n    while (elements.length > 0 && !shouldYield) {\r\n        const element = elements.pop();\r\n        renderNode(element!);\r\n        shouldYield = deadline.timeRemaining() < 1;\r\n    }\r\n\r\n    if (elements.length == 0) {\r\n        commitRootFragment();\r\n\r\n        processEffectQueue();\r\n        return;\r\n    }\r\n    requestIdleCallback(workLoop);\r\n}\r\n\r\nfunction renderNode(fiber: Fiber) {\r\n    if (fiber.type === \"FRAGMENT\") {\r\n        const isArray = !fiber.props.children[FRAGMENT_SYMBOL];\r\n        let noKey = false;\r\n        for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n            fiber.props.children[i].parent = fiber;\r\n\r\n            if (\r\n                isArray &&\r\n                fiber.props.children[i].props.key === undefined &&\r\n                fiber.renderFunction\r\n            ) {\r\n                noKey = true;\r\n            }\r\n\r\n            elements.push(fiber.props.children[i]);\r\n        }\r\n        if (noKey) {\r\n            console.error(\"Array children must have a key attribute\");\r\n        }\r\n        // console.log(fiber.props.children);\r\n    } else if (typeof fiber.type === \"function\") {\r\n        setCurrentFC(fiber);\r\n\r\n        const children = fiber.type(fiber.props);\r\n        clearCurrentFC();\r\n\r\n        if (Array.isArray(children)) {\r\n            // which means that the FC returned a fragment\r\n            // console.log(children);\r\n            for (let i = children.length - 1; i >= 0; i--) {\r\n                children[i].parent = fiber;\r\n                elements.push(children[i]);\r\n            }\r\n            fiber.props.children = children;\r\n        } else {\r\n            children.parent = fiber;\r\n            fiber.props.children.push(children);\r\n            elements.push(children);\r\n        }\r\n        // queue to run its effects\r\n        effectQueue.push(fiber);\r\n    } else {\r\n        if (!fiber.dom) fiber.dom = createNode(fiber);\r\n        let fiberParent: Fiber | undefined = fiber.parent;\r\n        while (fiberParent && !fiberParent.dom) {\r\n            fiberParent = fiberParent.parent;\r\n        }\r\n        if (fiberParent) {\r\n            fiberParent.dom?.appendChild(fiber.dom);\r\n        }\r\n\r\n        for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n            fiber.props.children[i].parent = fiber;\r\n            elements.push(fiber.props.children[i]);\r\n        }\r\n    }\r\n    // console.log(fiber);\r\n    setRenderFunction(fiber);\r\n}\r\n\r\nfunction createFiber(fiber: Fiber) {\r\n    if (fiber.type === \"FRAGMENT\") {\r\n        const isFragment = fiber.props.children[FRAGMENT_SYMBOL];\r\n        if (isFragment) {\r\n            for (const child of fiber.props.children) {\r\n                child.parent = fiber;\r\n                createFiber(child);\r\n            }\r\n        } else {\r\n            let noKey = false;\r\n            for (const child of fiber.props.children) {\r\n                child.parent = fiber;\r\n                if (child.props.key === undefined) {\r\n                    noKey = true;\r\n                }\r\n                createFiber(child);\r\n            }\r\n            if (noKey) {\r\n                console.error(\"Array children must have a key attribute\");\r\n            }\r\n        }\r\n    } else if (typeof fiber.type !== \"function\") {\r\n        for (const child of fiber.props.children) {\r\n            child.parent = fiber;\r\n            createFiber(child);\r\n        }\r\n    }\r\n    // console.log(fiber);\r\n    setRenderFunction(fiber);\r\n}\r\nfunction commitFiber(\r\n    fiber: Fiber,\r\n    referenceNode?: Node,\r\n    replace?: boolean,\r\n    needCreation?: boolean,\r\n    customParent?: Node\r\n) {\r\n    if (fiber.type === \"FRAGMENT\") {\r\n        for (const child of fiber.props.children) {\r\n            if (needCreation) child.parent = fiber;\r\n            commitFiber(\r\n                child,\r\n                referenceNode,\r\n                replace,\r\n                needCreation,\r\n                customParent\r\n            );\r\n        }\r\n    } else if (typeof fiber.type === \"function\") {\r\n        setCurrentFC(fiber);\r\n\r\n        const children = fiber.type(fiber.props);\r\n        clearCurrentFC();\r\n\r\n        // console.log(\"commit FC\", children);\r\n        if (Array.isArray(children)) {\r\n            // which means that the FC returned a fragment\r\n            // console.log(children);\r\n            for (const child of children) {\r\n                child.parent = fiber;\r\n                commitFiber(child, referenceNode, replace, true, customParent);\r\n            }\r\n            fiber.props.children = children;\r\n        } else {\r\n            children.parent = fiber;\r\n            fiber.props.children.push(children);\r\n            commitFiber(children, referenceNode, replace, true, customParent);\r\n        }\r\n        // queue to run its effects at the end of current stack\r\n        queueMicrotask(() => {\r\n            runAllEffects(fiber);\r\n        });\r\n    } else {\r\n        if (!fiber.dom) fiber.dom = createNode(fiber);\r\n\r\n        if (referenceNode) {\r\n            if (replace)\r\n                referenceNode.parentElement?.replaceChild(\r\n                    fiber.dom,\r\n                    referenceNode\r\n                );\r\n            else\r\n                referenceNode.parentElement?.insertBefore(\r\n                    fiber.dom,\r\n                    referenceNode\r\n                );\r\n        } else {\r\n            let parentDom: Node | undefined = undefined;\r\n            if (customParent) {\r\n                parentDom = customParent;\r\n            } else {\r\n                let fiberParent: Fiber | undefined = fiber.parent;\r\n\r\n                while (fiberParent && !fiberParent.dom) {\r\n                    fiberParent = fiberParent.parent;\r\n                }\r\n                parentDom = fiberParent?.dom;\r\n            }\r\n            parentDom?.appendChild(fiber.dom);\r\n        }\r\n        for (const child of fiber.props.children) {\r\n            if (needCreation) child.parent = fiber;\r\n\r\n            commitFiber(child, undefined, undefined, needCreation, fiber.dom);\r\n        }\r\n    }\r\n    if (needCreation) {\r\n        setRenderFunction(fiber);\r\n    }\r\n}\r\n\r\nlet ToCommitDeletion = true;\r\n\r\nfunction commitDeletion(fiber: Fiber, toClearReactiveFunction?: boolean) {\r\n    if (!fiber || !ToCommitDeletion) return;\r\n    if (fiber.renderFunction) {\r\n        if (toClearReactiveFunction)\r\n            clearReactiveFunction(fiber.renderFunction);\r\n        delete fiber.renderFunction;\r\n    }\r\n    if (fiber.dom) {\r\n        for (const prop in fiber.props) {\r\n            if (isEvent(prop)) {\r\n                let eventName = prop.toLowerCase().substring(2);\r\n                const useCapture =\r\n                    eventName !=\r\n                    (eventName = eventName.replace(CAPTURE_REGEX, \"$1\"));\r\n\r\n                fiber.dom.removeEventListener(\r\n                    eventName,\r\n                    fiber.props[prop],\r\n                    useCapture\r\n                );\r\n                delete fiber.props[prop];\r\n            } else if (typeof fiber.props[prop] === \"function\") {\r\n                clearReactiveAttributes(fiber.props[prop]);\r\n            } else if (prop === \"ref\" && fiber.props[prop] instanceof Ref) {\r\n                fiber.props[prop].current = null;\r\n            }\r\n        }\r\n\r\n        fiber.dom.remove();\r\n    }\r\n    if (typeof fiber.type === \"function\") {\r\n        cleanUpFC(fiber, fiber.props);\r\n        // @ts-expect-error\r\n        delete fiber.type;\r\n    }\r\n    fiber.props.children.forEach((child) => commitDeletion(child, true));\r\n}\r\n\r\nfunction setRenderFunction(fiber: Fiber) {\r\n    if (!fiber.renderFunction) return;\r\n    setReactiveFunction(fiber.renderFunction, fiber);\r\n}\r\n\r\nexport function updateFiber(prevFiber: Fiber, newValue) {\r\n    // console.log(\"Prev value\", prevFiber, newValue);\r\n    // startTime = performance.now();\r\n    if (isPrimitive(newValue)) {\r\n        // console.log(fiber, newValue);\r\n        const newFragment: Fiber = {\r\n            ...createTextChildren(newValue),\r\n            parent: prevFiber.parent,\r\n        };\r\n        createFiber(newFragment);\r\n        // console.log(\"New Text Fiber\", newFragment);\r\n\r\n        updateNode(prevFiber, newFragment);\r\n    } else if (Array.isArray(newValue)) {\r\n        const isFragment = newValue[FRAGMENT_SYMBOL];\r\n\r\n        const newFragment: Fiber = {\r\n            type: \"FRAGMENT\",\r\n            props: {\r\n                children: isFragment ? newValue : createChildren(newValue),\r\n            },\r\n            parent: prevFiber.parent,\r\n        };\r\n\r\n        createFiber(newFragment);\r\n        updateNode(prevFiber, newFragment);\r\n    } else {\r\n        const newFragment = { ...newValue, parent: prevFiber.parent };\r\n        createFiber(newFragment);\r\n        // console.log(\"New Node Fiber\", newFragment);\r\n        updateNode(prevFiber, newFragment);\r\n    }\r\n    // const endTime = performance.now();\r\n    // console.log(\"Update Time:\", (endTime - startTime).toFixed(2), \"ms\");\r\n}\r\n\r\nfunction replaceRenderFunction(prev: Fiber, next: Fiber) {\r\n    if (prev.renderFunction) {\r\n        next.renderFunction = prev.renderFunction;\r\n        // console.log(\"Replace render function\", prev, next);\r\n        // deleteReactiveFunction(prev.renderFunction);\r\n        setRenderFunction(next);\r\n    }\r\n}\r\n\r\nfunction replaceChildFromParent(prev: Fiber, next: Fiber, index?: number) {\r\n    if (index !== undefined) {\r\n        prev.parent.props.children[index] = next;\r\n        return;\r\n    }\r\n    prev.parent?.props.children.forEach((child, i) => {\r\n        if (child === prev) {\r\n            prev.parent.props.children[i] = next;\r\n        }\r\n    });\r\n}\r\n\r\nexport const isEvent = (key: string) =>\r\n    key.startsWith(\"on\") || key == \"onFocusOut\" || key == \"onFocusIn\";\r\nexport const isProperty = (key: string) =>\r\n    key !== \"children\" && !isEvent(key) && key !== \"key\" && key !== \"ref\";\r\nconst isNew = (prev: any, next: any, key: string) => prev[key] !== next[key];\r\nconst isGone = (prev: any, next: any, key: string) => !(key in next);\r\n\r\nfunction deepCompareFibers(fiberA: any, fiberB: any): boolean {\r\n    // Fast path: identical references\r\n    if (fiberA === fiberB) {\r\n        return true;\r\n    }\r\n\r\n    // Compare the fiber types (e.g., function for FCs, string for DOM nodes)\r\n    if (fiberA.type !== fiberB.type) {\r\n        return false;\r\n    }\r\n\r\n    // Compare keys if they exist\r\n    if (fiberA.props?.key !== fiberB.props?.key) {\r\n        return false;\r\n    }\r\n    return deepEqual(fiberA.props, fiberB.props);\r\n}\r\n\r\nfunction deepEqual(objA: any, objB: any): boolean {\r\n    if (objA === objB) {\r\n        // console.log(\"Signal prop\");\r\n\r\n        if (objA instanceof BaseSignal && objB instanceof BaseSignal)\r\n            return deepEqual(objA.value, objB.value);\r\n        if (Array.isArray(objA) && Array.isArray(objB)) {\r\n            if (objA.length !== objB.length) return false;\r\n            for (let i = 0; i < objA.length; i++) {\r\n                if (!deepEqual(objA[i], objB[i])) return false;\r\n            }\r\n        }\r\n        return true;\r\n    } // Same reference or primitive value\r\n\r\n    if (isPrimitive(objA) && isPrimitive(objB)) {\r\n        return objA === objB; // One is not an object or is null\r\n    }\r\n\r\n    if (typeof objA !== typeof objB) return false;\r\n\r\n    const keysA = Object.keys(objA);\r\n    const keysB = Object.keys(objB);\r\n\r\n    if (keysA.length !== keysB.length) return false; // Different number of keys\r\n\r\n    for (let key of keysA) {\r\n        if (key === \"children\") continue;\r\n        if (!objB.hasOwnProperty(key)) return false; // Missing key in one of them\r\n        if (!deepEqual(objA[key], objB[key])) return false; // Recurse for nested objects/arrays\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction findFirstDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n    if (!fiber) return;\r\n\r\n    if (fiber.dom) return fiber.dom;\r\n\r\n    for (const child of fiber.props.children) {\r\n        const dom = findFirstDom(child);\r\n        if (dom) return dom;\r\n    }\r\n}\r\n// function findFirstChildDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n//     if (!fiber) return;\r\n\r\n//     for (const child of fiber.props.children) {\r\n//         const dom = findFirstDom(child);\r\n//         if (dom) return dom;\r\n//     }\r\n// }\r\nfunction findLastDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n    if (!fiber) return;\r\n\r\n    if (fiber.dom) return fiber.dom;\r\n\r\n    for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n        const child = fiber.props.children[i];\r\n        const dom = findLastDom(child);\r\n        if (dom) return dom;\r\n    }\r\n}\r\nfunction findLastChildDom(fiber: Fiber): HTMLElement | Text | undefined {\r\n    if (!fiber) return;\r\n\r\n    for (let i = fiber.props.children.length - 1; i >= 0; i--) {\r\n        const child = fiber.props.children[i];\r\n        const dom = findLastDom(child);\r\n        if (dom) return dom;\r\n    }\r\n}\r\nfunction findParentFiberWithDom(fiber: Fiber): Fiber | undefined {\r\n    if (!fiber) return;\r\n    let fiberParent = fiber.parent;\r\n    while (fiberParent && !fiberParent.dom) {\r\n        fiberParent = fiberParent.parent;\r\n    }\r\n    return fiberParent;\r\n}\r\nfunction findNearestParentWithDom(fiber: Fiber): Fiber | undefined {\r\n    if (!fiber) return;\r\n    if (fiber.dom) return fiber;\r\n\r\n    let fiberParent = fiber.parent;\r\n    while (fiberParent && !fiberParent.dom) {\r\n        fiberParent = fiberParent.parent;\r\n    }\r\n    return fiberParent;\r\n}\r\n\r\nfunction updateNode(\r\n    prev: Fiber | undefined,\r\n    next: Fiber | undefined,\r\n    index?: number\r\n) {\r\n    if (!prev && !next) return;\r\n\r\n    if (prev && !next) {\r\n        commitDeletion(prev, true);\r\n        // console.log(\"to remove\", prev);\r\n        prev.parent.props.children = prev.parent.props.children.filter(\r\n            (child) => child !== prev\r\n        );\r\n    } else if (prev && next) {\r\n        const prevProps = prev.props;\r\n        const nextProps = next.props;\r\n        if (prev.type === \"FRAGMENT\" || typeof prev.type === \"function\") {\r\n            // PREV IS FRAGMENT\r\n            if (next.type === \"FRAGMENT\" || typeof next.type === \"function\") {\r\n                // console.log(\"Fragment-Fragment\", prev, next);\r\n                if (\r\n                    typeof prev.type === typeof next.type &&\r\n                    typeof prev.type === \"function\"\r\n                ) {\r\n                    const areSame = deepCompareFibers(prev, next);\r\n                    if (!areSame) {\r\n                        commitFiber(next, findFirstDom(prev), undefined, true);\r\n\r\n                        replaceRenderFunction(prev, next);\r\n                        commitDeletion(prev);\r\n                        replaceChildFromParent(prev, next, index);\r\n                    }\r\n                } else {\r\n                    // console.log(\"fragment-fragment\", { ...prev }, next);\r\n\r\n                    updateChildren(prev, next);\r\n                }\r\n                // replaceChildFromParent(prev, next);\r\n            } else {\r\n                next.parent = prev.parent;\r\n                let firstChild: Fiber | undefined = prev.props.children[0];\r\n                while (firstChild && !firstChild.dom)\r\n                    firstChild = firstChild.props.children[0];\r\n                commitFiber(next, firstChild?.dom);\r\n\r\n                replaceRenderFunction(prev, next);\r\n                // removing all nodes of previous fragment\r\n                commitDeletion(prev);\r\n                replaceChildFromParent(prev, next, index);\r\n            }\r\n        } else {\r\n            // PREV IS NODE\r\n\r\n            const node = prev.dom;\r\n            if (\r\n                prev.type === \"TEXT_CHILD\" &&\r\n                next.type === \"TEXT_CHILD\" &&\r\n                !next.dom\r\n            )\r\n                next.dom = prev.dom;\r\n            if (node === undefined) {\r\n                // console.error(\"no node found\", prev, next);\r\n                return;\r\n            }\r\n            // console.log(prev);\r\n            if (next.type === \"FRAGMENT\" || typeof next.type === \"function\") {\r\n                // console.log(\"Node-Fragment\");\r\n                next.parent = prev.parent;\r\n                replaceRenderFunction(prev, next);\r\n\r\n                commitFiber(next, node);\r\n                commitDeletion(prev);\r\n                replaceChildFromParent(prev, next, index);\r\n            } else {\r\n                // console.log(\"Node-Node\");\r\n                // remove old properties and event listeners from NODE\r\n                for (const prop in prevProps) {\r\n                    if (\r\n                        isProperty(prop) &&\r\n                        isGone(prevProps, nextProps, prop)\r\n                    ) {\r\n                        node[prop] = \"\";\r\n                        // console.log(\"property removed\", prop);\r\n                    } else if (\r\n                        isEvent(prop) &&\r\n                        (!(prop in nextProps) ||\r\n                            isNew(prevProps, nextProps, prop))\r\n                    ) {\r\n                        let eventName = prop.toLowerCase().substring(2);\r\n                        const useCapture =\r\n                            eventName !=\r\n                            (eventName = eventName.replace(\r\n                                CAPTURE_REGEX,\r\n                                \"$1\"\r\n                            ));\r\n\r\n                        node.removeEventListener(\r\n                            eventName,\r\n                            prevProps[prop],\r\n                            useCapture\r\n                        );\r\n                        // console.log(\"event listener removed\", prop);\r\n                    }\r\n                }\r\n                if (prev.type !== next.type) {\r\n                    // console.log(\"Different type\", prev, next);\r\n                    next.parent = prev.parent;\r\n\r\n                    replaceRenderFunction(prev, next);\r\n\r\n                    commitFiber(next, node, true);\r\n                    commitDeletion(prev);\r\n                    replaceChildFromParent(prev, next, index);\r\n\r\n                    // console.log(prev.parent);\r\n                } else {\r\n                    // add new properties\r\n                    // console.log(\"same type\", prev, next);\r\n\r\n                    for (const prop in nextProps) {\r\n                        if (\r\n                            isProperty(prop) &&\r\n                            isNew(prevProps, nextProps, prop)\r\n                        ) {\r\n                            node[prop] = nextProps[prop];\r\n                            // console.log(\r\n                            //     \"property added\",\r\n                            //     prop,\r\n                            //     nextProps[prop]\r\n                            // );\r\n                            prevProps[prop] = nextProps[prop];\r\n                        } else if (\r\n                            isEvent(prop) &&\r\n                            isNew(prevProps, nextProps, prop)\r\n                        ) {\r\n                            let eventName = prop.toLowerCase().substring(2);\r\n                            const useCapture =\r\n                                eventName !=\r\n                                (eventName = eventName.replace(\r\n                                    CAPTURE_REGEX,\r\n                                    \"$1\"\r\n                                ));\r\n                            node.addEventListener(\r\n                                eventName,\r\n                                nextProps[prop],\r\n                                useCapture\r\n                            );\r\n                            prevProps[prop] = nextProps[prop];\r\n                        }\r\n                    }\r\n                    updateChildren(prev, next);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction reconcileList(prev: Fiber, next: Fiber) {\r\n    const oldFibers = prev.props.children;\r\n    const newFibers = next.props.children;\r\n\r\n    // Create a map from key to fiber for oldFibers.\r\n    const oldMap: Record<string, any> = {};\r\n    for (let i = 0; i < oldFibers.length; i++) {\r\n        const key = oldFibers[i].props.key;\r\n        if (\r\n            key === null ||\r\n            key === undefined ||\r\n            oldMap.hasOwnProperty(String(key))\r\n        ) {\r\n            // If any fiber is missing a key, we cannot reconcile.\r\n            // oldFibers[i].props.key =\r\n            return false;\r\n        }\r\n        oldMap[String(key)] = oldFibers[i];\r\n    }\r\n    const referenceNode = findLastChildDom(prev)?.nextSibling as\r\n        | Node\r\n        | undefined;\r\n    // Create newChildren array based on newFibers order.\r\n    const fiberParent = findParentFiberWithDom(prev);\r\n    // const fragment = document.createDocumentFragment();\r\n\r\n    if (newFibers.length === 0) {\r\n        prev.props.children.length = 0;\r\n        if (fiberParent?.dom instanceof HTMLElement)\r\n            fiberParent.dom.innerHTML = \"\";\r\n        return;\r\n    }\r\n    const prevLen = prev.props.children.length;\r\n\r\n    // const newChildren = new Array(newFibers.length);\r\n    for (let i = 0; i < newFibers.length; i++) {\r\n        const newFiber = newFibers[i];\r\n        const key = newFiber.props.key;\r\n        const keyStr = String(key);\r\n        // If the fiber exists in the old list, reuse it.\r\n        if (oldMap.hasOwnProperty(keyStr)) {\r\n            const oldFiber = oldMap[keyStr];\r\n\r\n            if (prevLen > i) prev.props.children[i] = oldFiber;\r\n            else prev.props.children.push(oldFiber);\r\n\r\n            delete oldMap[keyStr];\r\n\r\n            const newFiber = next.props.children[i];\r\n\r\n            if (newFiber) newFiber.parent = prev;\r\n\r\n            updateNode(oldFiber, newFiber, i);\r\n            applyFiber(\r\n                prev.props.children[i],\r\n                fiberParent?.dom!,\r\n                referenceNode\r\n            );\r\n        } else {\r\n            // Otherwise, use the new fiber.\r\n            // console.log(first)\r\n            if (prevLen > i) prev.props.children[i] = newFiber;\r\n            else prev.props.children.push(newFiber);\r\n\r\n            newFiber.parent = prev;\r\n            commitFiber(\r\n                newFiber,\r\n                referenceNode,\r\n                false,\r\n                false,\r\n                fiberParent?.dom\r\n            );\r\n        }\r\n    }\r\n    for (const key in oldMap) {\r\n        if (oldMap.hasOwnProperty(key)) {\r\n            const fiber = oldMap[key];\r\n            commitDeletion(fiber, true);\r\n        }\r\n    }\r\n    while (prev.props.children.length > next.props.children.length) {\r\n        prev.props.children.pop();\r\n    }\r\n\r\n    // fiberParent?.dom?.appendChild(fragment);\r\n}\r\n\r\nfunction applyFiber(fiber: Fiber, parent: Node, referenceNode?: Node) {\r\n    if (fiber.dom) {\r\n        if (fiber.dom === parent || fiber.dom === referenceNode) return;\r\n        if (referenceNode) {\r\n            parent.insertBefore(fiber.dom, referenceNode);\r\n        } else parent.appendChild(fiber.dom);\r\n    } else {\r\n        for (const child of fiber.props.children) {\r\n            applyFiber(child, parent, referenceNode);\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateChildren(prev: Fiber, next: Fiber) {\r\n    const isList =\r\n        next.type === \"FRAGMENT\" && !next.props.children[FRAGMENT_SYMBOL];\r\n\r\n    const wasList =\r\n        prev.type === \"FRAGMENT\" && !prev.props.children[FRAGMENT_SYMBOL];\r\n\r\n    // console.log(isList, wasList);\r\n\r\n    if (isList && wasList) {\r\n        const result = reconcileList(prev, next);\r\n        if (result === false) {\r\n            updateNonListChildrenWithKeys(prev, next);\r\n        }\r\n    } else {\r\n        updateNonListChildrenWithKeys(prev, next);\r\n    }\r\n    if (next.type === \"FRAGMENT\" && next.props.children[FRAGMENT_SYMBOL]) {\r\n        prev.props.children[FRAGMENT_SYMBOL] = true;\r\n    } else {\r\n        prev.props.children[FRAGMENT_SYMBOL] = false;\r\n    }\r\n\r\n    prev.type = next.type;\r\n}\r\n\r\nfunction updateNonListChildren(prev: Fiber, next: Fiber) {\r\n    let len = Math.max(prev.props.children.length, next.props.children.length);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let prevChild = prev.props.children[i];\r\n        let nextChild = next.props.children[i];\r\n\r\n        if (nextChild) nextChild.parent = prev;\r\n        if (!prevChild && nextChild) {\r\n            commitFiber(\r\n                nextChild,\r\n                // @ts-expect-error\r\n                findLastDom(prev.props.children.at(-1))?.nextSibling\r\n            );\r\n            prev.props.children.push(nextChild);\r\n        } else if (!nextChild && prevChild) {\r\n            commitDeletion(prevChild, true);\r\n            prev.props.children.splice(i, 1);\r\n            len = prev.props.children.length;\r\n            i--;\r\n        } else {\r\n            updateNode(prevChild, nextChild, i);\r\n            const newLen = Math.max(\r\n                prev.props.children.length,\r\n                next.props.children.length\r\n            );\r\n            if (newLen < len) {\r\n                len = newLen;\r\n                i--;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction updateNonListChildrenWithKeys(prev: Fiber, next: Fiber) {\r\n    let len = Math.max(prev.props.children.length, next.props.children.length);\r\n    const oldMap: Record<string, { fiber: Fiber; index: number }> = {};\r\n    let count = 0;\r\n    for (let i = 0; i < prev.props.children.length; i++) {\r\n        const key = prev.props.children[i].props.key;\r\n        if (key === null || key === undefined) {\r\n            continue;\r\n        }\r\n        count++;\r\n        if (oldMap.hasOwnProperty(String(key))) {\r\n            console.warn(\"Found two children with the same key\", key);\r\n            console.warn(\r\n                \"When two fibers are found having same key the whole children will default to manual updates, which can be slower than with key based reconciliation\"\r\n            );\r\n            updateNonListChildren(prev, next);\r\n            return;\r\n        }\r\n        oldMap[String(key)] = { fiber: prev.props.children[i], index: i };\r\n    }\r\n    if (count == 0) {\r\n        updateNonListChildren(prev, next);\r\n        return;\r\n    }\r\n    const newMap: Record<\r\n        string,\r\n        { fiber: Fiber; newIndex: number; oldIndex: number }\r\n    > = {};\r\n\r\n    for (let i = 0; i < next.props.children.length; i++) {\r\n        const key = next.props.children[i].props.key;\r\n        if (key === null || key === undefined) {\r\n            continue;\r\n        }\r\n        const oldFiber = oldMap[String(key)];\r\n        if (oldFiber) {\r\n            if (newMap.hasOwnProperty(String(key))) {\r\n                console.warn(\"Found two children with the same key\", key);\r\n                console.warn(\r\n                    \"When two fibers are found having same key the whole children will default to manual updates, which can be slower than with key based reconciliation\"\r\n                );\r\n                updateNonListChildren(prev, next);\r\n                return;\r\n            }\r\n            newMap[String(key)] = {\r\n                fiber: oldFiber.fiber,\r\n                newIndex: i,\r\n                oldIndex: oldFiber.index,\r\n            };\r\n        }\r\n    }\r\n    // console.log(prev, next);\r\n    const parent = findNearestParentWithDom(prev);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let prevChild = prev.props.children[i];\r\n        let nextChild = next.props.children[i];\r\n        // console.log(prevChild, nextChild);\r\n\r\n        const nextKey = nextChild?.props.key ? String(nextChild.props.key) : \"\";\r\n        const isReused = newMap.hasOwnProperty(nextKey);\r\n\r\n        let prevKey = prevChild?.props.key ? String(prevChild.props.key) : \"\";\r\n\r\n        if (prevKey && nextKey && prevKey === nextKey) {\r\n            // console.log(\"same\", prevChild, nextChild);\r\n            updateNode(prevChild, nextChild, i);\r\n\r\n            if (parent?.dom) applyFiber(prev.props.children[i], parent.dom);\r\n            continue;\r\n        }\r\n\r\n        const isUsedLater =\r\n            newMap.hasOwnProperty(prevKey) && newMap[prevKey].newIndex > i;\r\n        const isUsedPreviously =\r\n            newMap.hasOwnProperty(prevKey) && newMap[prevKey].newIndex < i;\r\n\r\n        if (isUsedLater || isUsedPreviously) {\r\n            ToCommitDeletion = false;\r\n        }\r\n\r\n        if (nextChild) nextChild.parent = prev;\r\n\r\n        if (!prevChild && nextChild) {\r\n            if (isReused) {\r\n                const { fiber } = newMap[nextKey];\r\n\r\n                prev.props.children.push(fiber);\r\n\r\n                updateNode(fiber, nextChild, i);\r\n\r\n                if (parent?.dom) applyFiber(prev.props.children[i], parent.dom);\r\n            } else {\r\n                // needCreation just creates parent child heirarchy\r\n                if (parent?.dom)\r\n                    commitFiber(nextChild, undefined, false, false, parent.dom);\r\n                prev.props.children.push(nextChild);\r\n            }\r\n        } else if (!nextChild && prevChild) {\r\n            commitDeletion(prevChild, true);\r\n            prev.props.children.splice(i, 1);\r\n            len = prev.props.children.length;\r\n            i--;\r\n        } else {\r\n            if (isReused) {\r\n                const { fiber } = newMap[nextKey];\r\n\r\n                commitDeletion(prevChild, true);\r\n                // because updateNode can call commitDeletion internally\r\n                ToCommitDeletion = true;\r\n\r\n                prev.props.children[i] = fiber;\r\n\r\n                updateNode(fiber, nextChild, i);\r\n\r\n                if (parent?.dom) applyFiber(prev.props.children[i], parent.dom);\r\n            } else {\r\n                // console.log(ToCommitDeletion);\r\n                if (isUsedLater || isUsedPreviously) {\r\n                    if (parent?.dom)\r\n                        commitFiber(\r\n                            nextChild,\r\n                            undefined,\r\n                            false,\r\n                            false,\r\n                            parent.dom\r\n                        );\r\n                    prev.props.children[i] = nextChild;\r\n                } else {\r\n                    updateNode(prevChild, nextChild, i);\r\n                    if (parent?.dom)\r\n                        applyFiber(prev.props.children[i], parent.dom);\r\n\r\n                    const newLen = Math.max(\r\n                        prev.props.children.length,\r\n                        next.props.children.length\r\n                    );\r\n                    if (newLen < len) {\r\n                        len = newLen;\r\n                        i--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        ToCommitDeletion = true;\r\n    }\r\n    // console.log(prev.props.children, next.props.children);\r\n}\r\n\r\n// @ts-expect-error\r\nif (typeof process !== \"undefined\" && process.env.NODE_ENV === \"test\") {\r\n    // @ts-expect-error\r\n    module.exports = {\r\n        createFiber,\r\n        commitDeletion,\r\n        commitFiber,\r\n        updateFiber,\r\n        deepCompareFibers,\r\n        deepEqual,\r\n    };\r\n}\r\n","import { updateDomProp } from \"../rendering/createElements\";\r\nimport { updateFiber } from \"../rendering/render\";\r\nimport { Fiber } from \"../types\";\r\n\r\nlet scheduled = false;\r\nconst batch = new Set<Function>();\r\nconst depset = new Set();\r\nconst reactiveFiberMap = new WeakMap();\r\nconst domAttributeMap = new WeakMap<Function, HTMLElement | Text>();\r\n\r\nexport function batchUpdate(cb: Function) {\r\n    batch.add(cb);\r\n    if (!scheduled) {\r\n        scheduled = true;\r\n        queueMicrotask(() => {\r\n            // console.log(\"Current batch has: \", batch.size, \" Functions\");\r\n\r\n            batch.forEach((fn) => {\r\n                const dep = fn();\r\n                if (depset.has(dep)) {\r\n                    return;\r\n                }\r\n                depset.add(dep);\r\n                // effects and reactive nodes\r\n                if (dep.__cleanup && typeof dep.__cleanup === \"function\") {\r\n                    dep.__cleanup();\r\n                    dep.__cleanup = null;\r\n                }\r\n\r\n                const val = dep();\r\n\r\n                if (typeof val === \"function\") {\r\n                    dep.__cleanup = val;\r\n                }\r\n                // console.log(dep, \"dep\");\r\n                if (reactiveFiberMap.has(dep)) {\r\n                    // for updating reactive nodes\r\n                    const fiber = reactiveFiberMap.get(dep);\r\n                    if (fiber) {\r\n                        // console.log(\"dep\", fiber);\r\n                        updateFiber(fiber, val);\r\n                    }\r\n                }\r\n                if (domAttributeMap.has(dep)) {\r\n                    // for updating reactive nodes\r\n                    const dom = domAttributeMap.get(dep);\r\n                    if (dom && dep.__propName) {\r\n                        updateDomProp(dep.__propName, dom, val);\r\n                    }\r\n                }\r\n            });\r\n            depset.clear();\r\n            batch.clear();\r\n            scheduled = false;\r\n        });\r\n    }\r\n}\r\n\r\nexport function setReactiveFunction(fn: Function, fiber: Fiber) {\r\n    reactiveFiberMap.set(fn, fiber);\r\n}\r\nexport function setReactiveAttributes(fn: Function, dom: HTMLElement | Text) {\r\n    // console.log(\"reactive attrubite\", fn);\r\n    domAttributeMap.set(fn, dom);\r\n}\r\nexport function clearReactiveAttributes(fn: any) {\r\n    domAttributeMap.delete(fn);\r\n\r\n    const signals = fn.__signals;\r\n    if (signals) {\r\n        for (const signal of signals) {\r\n            signal.removeDep(fn);\r\n        }\r\n        fn.__signals = null;\r\n    }\r\n}\r\n\r\nexport function clearReactiveFunction(fn: Function) {\r\n    reactiveFiberMap.delete(fn);\r\n    // @ts-expect-error\r\n    const signals = fn.__signals;\r\n    if (signals) {\r\n        for (const signal of signals) {\r\n            signal.removeDep(fn);\r\n        }\r\n        // @ts-expect-error\r\n        fn.__signals = null;\r\n    }\r\n}\r\n\r\nexport function deleteReactiveFunction(fn: Function) {\r\n    reactiveFiberMap.delete(fn);\r\n}\r\n","import {\r\n    addEffect,\r\n    addSignal,\r\n    cleanUp,\r\n    cleanUpWFiber,\r\n    getCurrentFC,\r\n} from \"../rendering/functionalComponents\";\r\nimport { Fiber } from \"../types\";\r\nimport { isPlainObject, isPrimitive } from \"../utils/general\";\r\nimport { batchUpdate } from \"./batch\";\r\n\r\nlet currentReactiveFunction: any = null;\r\nlet currentEffect: any = null;\r\n\r\nfunction addSignalToReactiveFunction(signal: any) {\r\n    if (!currentReactiveFunction.__signals) {\r\n        currentReactiveFunction.__signals = new Set();\r\n    }\r\n    currentReactiveFunction.__signals.add(signal);\r\n}\r\nfunction addSignalToEffect(signal: any) {\r\n    if (!currentEffect.__signals) currentEffect.__signals = new Set();\r\n    currentEffect.__signals.add(signal);\r\n}\r\n\r\nexport function reactive(fn: Function) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"reactive takes a render function as the argument\");\r\n\r\n    currentReactiveFunction = fn;\r\n    const retVal = fn();\r\n    currentReactiveFunction = null;\r\n    if (\r\n        !isPrimitive(retVal) &&\r\n        isPlainObject(retVal) &&\r\n        !retVal.type &&\r\n        !retVal.props &&\r\n        !retVal.props?.children\r\n    )\r\n        throw new Error(\r\n            \"Reactive value must be primitive or functional component, got: \" +\r\n                typeof retVal\r\n        );\r\n    return retVal;\r\n}\r\nexport function reactiveAttribute(fn: Function) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"reactive takes a render function as the argument\");\r\n\r\n    currentReactiveFunction = fn;\r\n    const retVal = fn();\r\n    currentReactiveFunction = null;\r\n\r\n    return retVal;\r\n}\r\nexport function createEffect(fn: Function) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"createEffect takes a effect function as the argument\");\r\n\r\n    addEffect(fn);\r\n    if (!getCurrentFC()) runEffect(fn);\r\n}\r\n\r\nexport function runEffect(effect: Function, fiber?: Fiber) {\r\n    if (typeof effect !== \"function\") return;\r\n\r\n    currentEffect = effect;\r\n\r\n    const effectCleanup = effect();\r\n\r\n    if (currentEffect.__signals && typeof effectCleanup === \"function\") {\r\n        currentEffect.__cleanup = effectCleanup;\r\n    }\r\n\r\n    if (\r\n        !currentEffect.__signals &&\r\n        effectCleanup &&\r\n        typeof effectCleanup === \"function\"\r\n    ) {\r\n        // which means this effect does not have any signals associated with so its just a cleanup function that we need to call when the component unmounts\r\n        if (!fiber) {\r\n            cleanUp(effectCleanup);\r\n        } else {\r\n            cleanUpWFiber(effectCleanup, fiber);\r\n        }\r\n    }\r\n\r\n    currentEffect = null;\r\n}\r\n\r\nfunction computed<T extends NormalSignal | any[] | Record<any, any>>(\r\n    fn: () => T\r\n) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"computed takes a function as the argument\");\r\n\r\n    let firstRun = getCurrentFC() !== null;\r\n    currentEffect = () => {\r\n        if (firstRun) {\r\n            firstRun = false;\r\n            return;\r\n        }\r\n        signal.update(fn());\r\n    };\r\n\r\n    addEffect(currentEffect);\r\n\r\n    const val = fn();\r\n\r\n    // @ts-expect-error - Type assertion for signal\r\n    const signal = createSignal<T>(val);\r\n\r\n    currentEffect = null;\r\n    return {\r\n        get value() {\r\n            return signal.value;\r\n        },\r\n    };\r\n}\r\n\r\ntype PromiseOverload<T> =\r\n    | { status: \"pending\"; data: null; error: null }\r\n    | { status: \"resolved\"; data: T; error: null }\r\n    | { status: \"rejected\"; data: null; error: Error };\r\n\r\nexport function createPromise<T>(fn: () => Promise<T>) {\r\n    if (typeof fn !== \"function\")\r\n        throw new Error(\"createPromise takes a function as the argument\");\r\n    const promise = fn();\r\n\r\n    if (!(promise instanceof Promise)) {\r\n        throw new Error(\r\n            \"createPromise takes a function that returns a promise\"\r\n        );\r\n    }\r\n    const triggerSignal = createSignal<PromiseOverload<T>>({\r\n        status: \"pending\",\r\n        data: null,\r\n        error: null,\r\n    });\r\n\r\n    promise\r\n        .then((val) => {\r\n            triggerSignal.update((prev) => {\r\n                prev.data = val;\r\n                prev.status = \"resolved\";\r\n            });\r\n        })\r\n        .catch((err) => {\r\n            triggerSignal.update((prev) => {\r\n                prev.error = err;\r\n                prev.status = \"rejected\";\r\n            });\r\n        });\r\n\r\n    return {\r\n        get value() {\r\n            return triggerSignal.value;\r\n        },\r\n    };\r\n}\r\n\r\nexport class Ref<T extends EventTarget> {\r\n    current: T | null;\r\n    constructor(val: T | null) {\r\n        this.current = val;\r\n    }\r\n}\r\n\r\nexport function createRef<T extends EventTarget>() {\r\n    const ref = new Ref<T>(null);\r\n    return ref;\r\n}\r\n\r\n// const NonMutatingArrayMethods = [\r\n//     \"constructor\",\r\n//     \"concat\",\r\n//     \"every\",\r\n//     \"filter\",\r\n//     \"find\",\r\n//     \"findIndex\",\r\n//     \"flat\",\r\n//     \"flatMap\",\r\n//     \"forEach\",\r\n//     \"includes\",\r\n//     \"indexOf\",\r\n//     \"join\",\r\n//     \"map\",\r\n//     \"reduce\",\r\n//     \"reduceRight\",\r\n//     \"slice\",\r\n//     \"some\",\r\n//     \"toLocaleString\",\r\n//     \"toString\",\r\n// ];\r\nconst MutatingMethods = [\r\n    \"push\",\r\n    \"pop\",\r\n    \"unshift\",\r\n    \"shift\",\r\n    \"splice\",\r\n    \"fill\",\r\n    \"copyWithin\",\r\n    \"sort\",\r\n    \"reverse\",\r\n];\r\n\r\ntype DeepReadonly<T> = {\r\n    readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\r\n};\r\n\r\n/**\r\n *\r\n * Base class for signals.\r\n */\r\nexport abstract class BaseSignal<T> {\r\n    protected _val: T;\r\n    protected deps: Set<Function>;\r\n    protected isNotified: boolean = false;\r\n\r\n    constructor(val: T) {\r\n        this._val = val;\r\n        this.deps = new Set();\r\n    }\r\n\r\n    protected notify() {\r\n        if (this.isNotified) return;\r\n\r\n        if (this.deps.size !== 0) this.isNotified = true;\r\n\r\n        this.deps.forEach((dep) => {\r\n            batchUpdate(() => {\r\n                // Reset the flag before calling the dependency\r\n                this.isNotified = false;\r\n                return dep;\r\n            });\r\n        });\r\n    }\r\n\r\n    public removeDep(fn: Function) {\r\n        this.deps.delete(fn);\r\n    }\r\n\r\n    public clearDeps() {\r\n        this.deps.clear();\r\n    }\r\n\r\n    abstract get value(): T | DeepReadonly<T>;\r\n\r\n    abstract update(val: T | ((prev: T) => T)): void;\r\n}\r\n\r\ntype NormalSignal = boolean | string | number | undefined | null | Error;\r\n/**\r\n * Signal for primitive types.\r\n */\r\nexport class PrimitiveSignal<T extends NormalSignal> extends BaseSignal<T> {\r\n    constructor(val: T) {\r\n        if (!isPrimitive(val)) {\r\n            throw new Error(\r\n                \"Invalid type for PrimitiveSignal. Valid types: [boolean, string, number, undefined, null]\"\r\n            );\r\n        }\r\n        super(val);\r\n    }\r\n\r\n    get value(): T {\r\n        if (currentEffect) {\r\n            this.deps.add(currentEffect);\r\n            addSignalToEffect(this);\r\n        }\r\n        if (currentReactiveFunction) {\r\n            this.deps.add(currentReactiveFunction);\r\n\r\n            addSignalToReactiveFunction(this);\r\n        }\r\n        // (Optional) debug logging:\r\n        // console.log(this.deps);\r\n        return this._val;\r\n    }\r\n\r\n    public update(val: T | ((prev: T) => T)) {\r\n        if (typeof val === \"function\") {\r\n            const newVal = val(this._val);\r\n            if (!isPrimitive(newVal)) {\r\n                throw new Error(\r\n                    \"Invalid type for PrimitiveSignal. Valid types: [boolean, string, number, undefined, null]\"\r\n                );\r\n            }\r\n            if (newVal === this._val) return;\r\n            this._val = newVal;\r\n            this.notify();\r\n        } else {\r\n            if (!isPrimitive(val)) {\r\n                throw new Error(\r\n                    \"Invalid type for PrimitiveSignal. Valid types: [boolean, string, number, undefined, null]\"\r\n                );\r\n            }\r\n            if (val === this._val) return;\r\n\r\n            this._val = val;\r\n\r\n            this.notify();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Signal for arrays.\r\n */\r\nexport class ArraySignal<T extends any[]> extends BaseSignal<T> {\r\n    private updateCalled: boolean = false;\r\n\r\n    constructor(val: T) {\r\n        if (!Array.isArray(val)) {\r\n            throw new Error(\r\n                \"Invalid type for ArraySignal; value must be an array\"\r\n            );\r\n        }\r\n        // Call the base constructor with a proxy-wrapped array.\r\n        super(val);\r\n        this._val = this.createProxy(val);\r\n    }\r\n\r\n    private createProxy(val: T): T {\r\n        return new Proxy(val, {\r\n            get: (target, prop) => {\r\n                const value = target[prop as any];\r\n                // If a function is accessed, wrap it to trigger notifications on mutation.\r\n\r\n                if (typeof value === \"function\") {\r\n                    if (\r\n                        MutatingMethods.includes(String(prop)) &&\r\n                        !this.updateCalled\r\n                    ) {\r\n                        throw new Error(\r\n                            \"Cannot set a value on an array signal, use the update method for updating the array.\"\r\n                        );\r\n                    }\r\n\r\n                    return (...args: any[]) => {\r\n                        const result = value.apply(target, args);\r\n                        // Notify if the method is mutating.\r\n                        if (MutatingMethods.includes(String(prop))) {\r\n                            this.notify();\r\n                        }\r\n                        return result;\r\n                    };\r\n                }\r\n                return value;\r\n            },\r\n            set: (target, prop, newValue) => {\r\n                if (!this.updateCalled) {\r\n                    throw new Error(\r\n                        \"Cannot set a value on an array signal, use the update method for updating the array.\"\r\n                    );\r\n                }\r\n                target[prop as any] = newValue;\r\n                this.notify();\r\n                return true;\r\n            },\r\n        });\r\n    }\r\n\r\n    get value(): DeepReadonly<T> {\r\n        if (currentEffect) {\r\n            this.deps.add(currentEffect);\r\n            addSignalToEffect(this);\r\n        }\r\n        if (currentReactiveFunction) {\r\n            this.deps.add(currentReactiveFunction);\r\n            addSignalToReactiveFunction(this);\r\n        }\r\n\r\n        return this._val;\r\n    }\r\n\r\n    public update(val: T | ((prev: T) => void)) {\r\n        this.updateCalled = true;\r\n        if (typeof val === \"function\") {\r\n            val(this._val);\r\n        } else {\r\n            if (!Array.isArray(val)) {\r\n                throw new Error(\r\n                    \"Invalid type for ArraySignal; value must be an array\"\r\n                );\r\n            }\r\n            if (val === this._val) return;\r\n\r\n            this._val = this.createProxy(val);\r\n\r\n            this.notify();\r\n        }\r\n        this.updateCalled = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Signal for plain objects.\r\n */\r\nexport class ObjectSignal<T extends Record<any, any>> extends BaseSignal<T> {\r\n    private updateCalled: boolean = false;\r\n    constructor(val: T) {\r\n        if (!isPlainObject(val)) {\r\n            throw new Error(\r\n                \"Invalid type for ObjectSignal; value must be a plain object\"\r\n            );\r\n        }\r\n        super(val);\r\n        this._val = this.createProxy(val);\r\n    }\r\n    private createInternalArrayProxy<A extends any[]>(val: A): A {\r\n        return new Proxy(val, {\r\n            get: (target, prop) => {\r\n                const value = target[prop as any];\r\n                // If a function is accessed, wrap it to trigger notifications on mutation.\r\n                if (typeof value === \"function\") {\r\n                    if (\r\n                        !this.updateCalled &&\r\n                        MutatingMethods.includes(String(prop))\r\n                    ) {\r\n                        throw new Error(\r\n                            \"Cannot set a value on an object signal, use the update method for updating the object.\"\r\n                        );\r\n                    }\r\n\r\n                    return (...args: any[]) => {\r\n                        const result = value.apply(target, args);\r\n                        // Notify if the method is mutating.\r\n                        if (MutatingMethods.includes(String(prop))) {\r\n                            this.notify();\r\n                        }\r\n                        return result;\r\n                    };\r\n                }\r\n                return value;\r\n            },\r\n            set: (target, prop, newValue) => {\r\n                if (!this.updateCalled) {\r\n                    throw new Error(\r\n                        \"Cannot set a value on an object signal, use the update method for updating the object.\"\r\n                    );\r\n                }\r\n                target[prop as any] = newValue;\r\n                this.notify();\r\n                return true;\r\n            },\r\n        });\r\n    }\r\n    private createProxy(val: T): T {\r\n        return new Proxy(val, {\r\n            get: (target, prop) => {\r\n                const value = target[prop as any];\r\n                if (Array.isArray(value)) {\r\n                    // @ts-expect-error\r\n                    target[prop as any] =\r\n                        this.createInternalArrayProxy<typeof value>(value);\r\n\r\n                    return target[prop as any];\r\n                }\r\n                // console.log(\"get\", target, prop, value);\r\n                return value;\r\n            },\r\n            set: (target, prop, newValue) => {\r\n                if (!this.updateCalled) {\r\n                    throw new Error(\r\n                        \"Cannot set a value on an object signal, use the update method for updating the object.\"\r\n                    );\r\n                }\r\n                // Do not allow functions to be set as values.\r\n                if (typeof newValue === \"function\") return false;\r\n                // For nested objects, wrap them as well.\r\n                if (typeof newValue === \"object\" && newValue !== null) {\r\n                    newValue = this.createProxy(newValue);\r\n                }\r\n                if (newValue === target[prop as any]) return true;\r\n\r\n                // @ts-expect-error\r\n                target[prop as any] = newValue;\r\n\r\n                this.notify();\r\n\r\n                return true;\r\n            },\r\n            deleteProperty: (target, prop) => {\r\n                const result = delete target[prop as any];\r\n                this.notify();\r\n                return result;\r\n            },\r\n        });\r\n    }\r\n\r\n    get value(): DeepReadonly<T> {\r\n        if (currentEffect) {\r\n            this.deps.add(currentEffect);\r\n            addSignalToEffect(this);\r\n        }\r\n        if (currentReactiveFunction) {\r\n            this.deps.add(currentReactiveFunction);\r\n            addSignalToReactiveFunction(this);\r\n        }\r\n        return this._val;\r\n    }\r\n\r\n    public update(val: T | ((prev: T) => void)) {\r\n        this.updateCalled = true;\r\n        if (typeof val === \"function\") {\r\n            val(this._val);\r\n        } else {\r\n            if (!isPlainObject(val)) {\r\n                throw new Error(\r\n                    \"Invalid type for ObjectSignal; value must be a plain object\"\r\n                );\r\n            }\r\n            if (val === this._val) return;\r\n            this._val = this.createProxy(val);\r\n            this.notify();\r\n        }\r\n        this.updateCalled = false;\r\n    }\r\n}\r\n\r\nexport interface PublicSignal<T> {\r\n    readonly value: DeepReadonly<T>;\r\n    update(val: T | ((prev: T) => T)): void;\r\n}\r\n\r\nexport interface PublicArraySignal<T extends any[]> extends PublicSignal<T> {\r\n    update(val: T | ((prev: T) => void)): void; // Mutation allowed\r\n}\r\n\r\nexport interface PublicObjectSignal<T extends Record<any, any>>\r\n    extends PublicSignal<T> {\r\n    update(val: T | ((prev: T) => void)): void; // Mutation allowed\r\n}\r\n/**\r\n * Overloaded factory function to create a signal.\r\n */\r\nfunction createSignal<T extends NormalSignal>(val: T): PublicSignal<T>;\r\nfunction createSignal<T extends any[]>(val: T): PublicArraySignal<T>;\r\nfunction createSignal<T extends Record<any, any>>(\r\n    val: T\r\n): PublicObjectSignal<T>;\r\n\r\nfunction createSignal<T extends NormalSignal | any[] | Record<any, any>>(\r\n    val: T\r\n) {\r\n    if (typeof val === \"function\") {\r\n        throw new Error(\"Functions cannot be used as signal value\");\r\n    }\r\n\r\n    if (typeof val === \"object\" && val !== null) {\r\n        if (Array.isArray(val)) {\r\n            const signal = new ArraySignal(val);\r\n            addSignal(signal);\r\n            return {\r\n                get value() {\r\n                    return signal.value;\r\n                },\r\n                update: signal.update.bind(signal) as typeof signal.update,\r\n            };\r\n        } else if (isPlainObject(val)) {\r\n            const signal = new ObjectSignal(val);\r\n            addSignal(signal);\r\n            return {\r\n                get value() {\r\n                    return signal.value;\r\n                },\r\n                update: signal.update.bind(signal) as typeof signal.update,\r\n            };\r\n        } else {\r\n            throw new Error(\r\n                \"Invalid type for signal initialization: \" + typeof val\r\n            );\r\n        }\r\n    } else if (isPrimitive(val)) {\r\n        const signal = new PrimitiveSignal(val);\r\n        addSignal(signal);\r\n        return {\r\n            get value() {\r\n                return signal.value;\r\n            },\r\n            update: signal.update.bind(signal) as typeof signal.update,\r\n        };\r\n    } else {\r\n        throw new Error(\r\n            \"Invalid type for signal initialization: \" + typeof val\r\n        );\r\n    }\r\n}\r\n\r\nexport { computed, createSignal };\r\n","import { BaseSignal, runEffect } from \"../signals/signal\";\r\nimport { Fiber } from \"../types\";\r\n\r\nlet currentFC: Fiber | null = null;\r\nlet fcMap = new WeakMap<\r\n    Fiber,\r\n    {\r\n        signals: Set<BaseSignal<any>>;\r\n        cleanup: Function[];\r\n        effects: Set<Function>;\r\n    }\r\n>();\r\n\r\nexport function setCurrentFC(fc: Fiber) {\r\n    currentFC = fc;\r\n}\r\n\r\nexport function clearCurrentFC() {\r\n    currentFC = null;\r\n}\r\nexport function getCurrentFC() {\r\n    return currentFC;\r\n}\r\n\r\nexport function runAllEffects(FC: Fiber) {\r\n    if (fcMap.has(FC)) {\r\n        const fcData = fcMap.get(FC)!;\r\n\r\n        for (const effect of fcData.effects) {\r\n            runEffect(effect, FC);\r\n        }\r\n    }\r\n}\r\n\r\nexport function cleanUp(fn: Function) {\r\n    if (currentFC) {\r\n        // console.log(currentFC, fcMap.has(currentFC));\r\n        if (fcMap.has(currentFC)) {\r\n            const fcData = fcMap.get(currentFC)!;\r\n\r\n            fcData.cleanup.push(fn);\r\n        } else {\r\n            fcMap.set(currentFC, {\r\n                signals: new Set(),\r\n                cleanup: [fn],\r\n                effects: new Set(),\r\n            });\r\n        }\r\n    }\r\n}\r\nexport function cleanUpWFiber(fn: Function, fiber: Fiber) {\r\n    if (fiber) {\r\n        // console.log(currentFC, fcMap.has(currentFC));\r\n        if (fcMap.has(fiber)) {\r\n            const fcData = fcMap.get(fiber)!;\r\n\r\n            fcData.cleanup.push(fn);\r\n        } else {\r\n            fcMap.set(fiber, {\r\n                signals: new Set(),\r\n                cleanup: [fn],\r\n                effects: new Set(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport function addEffect(fn: Function) {\r\n    if (currentFC) {\r\n        if (fcMap.has(currentFC)) {\r\n            const fcData = fcMap.get(currentFC)!;\r\n            fcData.effects.add(fn);\r\n        } else {\r\n            const effects = new Set<Function>();\r\n            effects.add(fn);\r\n            fcMap.set(currentFC, {\r\n                signals: new Set(),\r\n                cleanup: [],\r\n                effects: effects,\r\n            });\r\n        }\r\n    }\r\n}\r\nexport function addSignal(signal: BaseSignal<any>) {\r\n    if (currentFC) {\r\n        if (fcMap.has(currentFC)) {\r\n            const fcData = fcMap.get(currentFC)!;\r\n            fcData.signals.add(signal);\r\n        } else {\r\n            const signals = new Set<BaseSignal<any>>();\r\n            signals.add(signal);\r\n            fcMap.set(currentFC, {\r\n                signals: signals,\r\n                cleanup: [],\r\n                effects: new Set(),\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport function cleanUpFC(currentFC, props) {\r\n    const fcData = fcMap.get(currentFC)!;\r\n    if (fcData) {\r\n        // console.log(\"Cleaning up FC\", currentFC, fcData);\r\n        if (fcData.cleanup) {\r\n            for (const fn of fcData.cleanup) {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        fcData.cleanup = [];\r\n\r\n        for (const effect of fcData.effects) {\r\n            // @ts-expect-error\r\n            if (effect.__cleanup && typeof effect.__cleanup === \"function\") {\r\n                // @ts-expect-error\r\n                effect.__cleanup();\r\n            }\r\n            // @ts-expect-error\r\n            if (effect.__signals) {\r\n                // @ts-expect-error\r\n                for (const signal of effect.__signals) {\r\n                    signal.removeDep(effect);\r\n                }\r\n            }\r\n            // @ts-expect-error\r\n            delete effect.__signals;\r\n            // @ts-expect-error\r\n            delete effect.__cleanup;\r\n        }\r\n\r\n        fcData.signals.forEach((signal) => signal.clearDeps());\r\n        fcData.signals.clear();\r\n    }\r\n    fcMap.delete(currentFC);\r\n}\r\n","import { ComponentChildren, createSignal, Fiber, PublicSignal } from \"../index\";\r\n\r\ndeclare const FRAGMENT = \"FRAGMENT\";\r\n\r\n// If the component takes no parameters, treat its props as {}\r\ntype PropsOf<T extends (...args: any) => any> = Parameters<T> extends []\r\n    ? {}\r\n    : Parameters<T>[0];\r\n\r\nexport function lazy<T extends (props: any) => any>(\r\n    importFn: () => Promise<{ default: T }>\r\n): (\r\n    props: PropsOf<T> & {\r\n        fallback?: ComponentChildren;\r\n        errorFallback?:\r\n            | ComponentChildren\r\n            | ((error: Error) => ComponentChildren);\r\n    }\r\n) => ReturnType<T> {\r\n    let Component: T | null = null;\r\n\r\n    const load = (\r\n        loading: PublicSignal<boolean>,\r\n        error: PublicSignal<Error | null>\r\n    ) => {\r\n        if (!Component) {\r\n            importFn()\r\n                .then((mod) => {\r\n                    if (mod.default) {\r\n                        if (typeof mod.default !== \"function\") {\r\n                            throw new Error(\r\n                                \"Lazy-loaded component must be a functional component\"\r\n                            );\r\n                        }\r\n                        Component = mod.default;\r\n\r\n                        loading.update(false);\r\n                        error.update(null);\r\n                    } else {\r\n                        error.update(\r\n                            new Error(\r\n                                \"No default export found from lazy-loaded module\"\r\n                            )\r\n                        );\r\n                    }\r\n                })\r\n                .catch((err) => {\r\n                    error.update(err);\r\n                    loading.update(false);\r\n                });\r\n        } else {\r\n            loading.update(false);\r\n            error.update(null);\r\n        }\r\n    };\r\n\r\n    return (\r\n        props: PropsOf<T> & {\r\n            fallback?: Node;\r\n            errorFallback?: Node;\r\n        }\r\n    ): ReturnType<T> => {\r\n        const loading = createSignal<boolean>(true);\r\n        const error = createSignal<Error | null>(null);\r\n\r\n        load(loading, error);\r\n        // Validate fallback and errorFallback types\r\n        const isValidNode = (val: any) =>\r\n            typeof val === \"string\" ||\r\n            (val && typeof val === \"object\" && \"props\" in val && \"type\" in val);\r\n\r\n        if (props.fallback !== undefined && !isValidNode(props.fallback)) {\r\n            throw new Error(\r\n                \"Invalid fallback: Expected a string or a valid JSX node.\"\r\n            );\r\n        }\r\n        if (\r\n            props.errorFallback !== undefined &&\r\n            !(\r\n                typeof props.errorFallback === \"function\" ||\r\n                isValidNode(props.errorFallback)\r\n            )\r\n        ) {\r\n            throw new Error(\r\n                \"Invalid errorFallback: Expected a string, a valid JSX node, or a function returning a JSX node.\"\r\n            );\r\n        }\r\n\r\n        return (\r\n            <>\r\n                {() =>\r\n                    loading.value\r\n                        ? props.fallback\r\n                        : error.value !== null\r\n                        ? props.errorFallback\r\n                            ? typeof props.errorFallback === \"function\"\r\n                                ? props.errorFallback(error.value)\r\n                                : props.errorFallback\r\n                            : \"Unknown error occurred while lazy loading component, use errorFallback prop to override\"\r\n                        : // @ts-expect-error\r\n                          Component && <Component {...props} />\r\n                }\r\n            </>\r\n        ) as unknown as ReturnType<T>;\r\n    };\r\n}\r\n"],"names":["CAPTURE_REGEX","isProperty","newFiber","currentFC"],"mappings":"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"}